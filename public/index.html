<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FFT Synthesis</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Dosis" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">FFT Synthesis</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cooley-tukey-algorithm">Cooley-Tukey algorithm</a><ul>
<li><a href="#array-arithmetic">Array arithmetic</a></li>
<li><a href="#array-methods">Array methods</a></li>
</ul></li>
<li><a href="#codelets-and-twiddles">Codelets and Twiddles</a><ul>
<li><a href="#codelets">Codelets</a></li>
<li><a href="#calling-genfft">Calling GenFFT</a></li>
<li><a href="#twiddle-factors">Twiddle factors</a></li>
<li><a href="#unit-tests">Unit tests</a></li>
</ul></li>
<li><a href="#abstract-syntax-tree">Abstract Syntax Tree</a><ul>
<li><a href="#type-lists">Type lists</a></li>
<li><a href="#opencl-namespaces">OpenCL namespaces</a></li>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#generating-code">Generating code</a></li>
<li><a href="#ast-module">AST Module</a></li>
</ul></li>
<li><a href="#synthesis-of-fft">Synthesis of FFT</a><ul>
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#synthesis-module">Synthesis Module</a></li>
</ul></li>
<li><a href="#appendix-miscellaneous-functions">Appendix: Miscellaneous functions</a><ul>
<li><a href="#list-manipulation">List manipulation</a></li>
</ul></li>
<li><a href="#unit-tests-1">Unit tests</a></li>
</ul>
</nav>
<h2 id="cooley-tukey-algorithm">Cooley-Tukey algorithm</h2>
<p>(sampled from Frigo 1999. I changed array indices to <span class="math inline">\(k, l, m\)</span>, <span class="math inline">\(n\)</span> denoting the length of the array.)</p>
<p>The (forward) discrete Fourier transform of <span class="math inline">\(X\)</span> is the array <span class="math inline">\(Y\)</span> given by</p>
<p><span id="eq:dft" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[l] = \sum_{k=0}^{n-1} X[k] w_n^{-kl},\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span> </p>
<p>where</p>
<p><span id="eq:wn" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[w_n = \exp\left(\frac{2\pi i}{n}\right).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span> </p>
<p>So <span class="math inline">\(w_n^{-kl}\)</span> denotes <span class="math inline">\(w_n\)</span> <em>to the power of</em> <span class="math inline">\(-kl\)</span>.</p>
<p>In the case that <span class="math inline">\(X\)</span> is real valued, <span class="math inline">\(Y\)</span> will have <em>hermitian symmetry</em></p>
<p><span id="eq:hermitian-symmetry" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[n - k] = Y^*[k].\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(3)</span></span> </p>
<p>The backward DFT flips the sign at the exponent of <span class="math inline">\(w_n\)</span>, giving</p>
<p><span id="eq:idft" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[l] = \sum_{k=0}^{n-1} X[k] w_n^{kl}.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(4)</span></span> </p>
<p>Now suppose that <span class="math inline">\(n\)</span> can be factored into <span class="math inline">\(n = n_1 n_2\)</span>. We may now view the arrays <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> in a rectangular shape, where</p>
<p><span class="math display">\[X[k] = X[k_1 n_2 + k_2] = X[k_1, k_2].\]</span></p>
<p>Also, let <span class="math inline">\(Y\)</span> take the transposed shape of <span class="math inline">\(X\)</span>,</p>
<p><span class="math display">\[Y[l] = Y[l_1 + l_2 n_1] = Y[l_1, l_2].\]</span></p>
<p>Then eq. <a href="#eq:dft">1</a> can be written as</p>
<p><span class="math display">\[Y[l_1, l_2] = \sum_{k_2 = 0}^{n_2 - 1} \left[\left(\sum_{k_1 = 0}^{n_1-1} X[k_1, k_2] w_{n_1}^{-k_1 l_1}\right) w_n^{l_1 k_2}\right] w_{n_2}^{-l_2 k_2}.\]</span></p>
<p>Also known as the <strong>Cooley-Tukey fast Fourier transform</strong>.</p>
<p>This separates the DFT in an inner and outer transform, of sizes <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span>. The output of the inner transform is multiplied by <strong>twiddle factors</strong> <span class="math inline">\(w_n^{-l_1 k_2}\)</span>, before the outer transform is done.</p>
<h3 id="array-arithmetic">Array arithmetic</h3>
<figure>
<img src="cooley-tukey-20.svg" alt="Figure 1: Cooley-Tukey algorithm for an n=20 array." id="fig:cooley-tukey-array" /><figcaption><span>Figure 1:</span> Cooley-Tukey algorithm for an <span class="math inline">\(n=20\)</span> array.</figcaption>
</figure>
<p>We will express different stages of the FFT by applying a vectorised FFT on a multi-dimensional strided numeric array. In the following example we compute an <span class="math inline">\(n=20\)</span> transform by doing four radix-5 transforms followed by five <span class="math inline">\(2 \times 2\)</span> transforms. The abstraction of using multi-dimensional arrays is a useful one to keep track of the offsets and strides involved, see fig. <a href="#fig:cooley-tukey-array">1</a>.</p>
<p>We define the <code>Array</code> module to handle array manipulation in abstraction, similar to array slicing in NumPy.</p>
<p><em>file: «src/Array.hs»=</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">module</span> <span class="dt">Array</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Complex</span> (<span class="dt">Complex</span>(..))</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="op">&lt;&lt;</span>array<span class="op">-</span>numeric<span class="op">-</span><span class="kw">class</span><span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="op">&lt;&lt;</span>array<span class="op">-</span>types<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="op">&lt;&lt;</span>array<span class="op">-</span>methods<span class="op">&gt;&gt;</span></a></code></pre></div>
<h4 id="numeric-types">Numeric types</h4>
<p>The <code>NumericType</code> type-class is defined so that we can constrain functions to work with <code>Float</code>, <code>Double</code> or <code>Complex a</code>. This also gives information on the byte size of each numeric type. We need to give <code>byteSize</code> an argument for it to be able to deduce the type, for which we use the <code>Proxy</code> type.</p>
<p><em>«array-numeric-class»=</em></p>
<div class="sourceCode" id="array-numeric-class"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-numeric-class-1" title="1"><span class="kw">class</span> <span class="dt">NumericType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="array-numeric-class-2" title="2"><span class="ot">    byteSize ::</span> proxy a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="array-numeric-class-3" title="3"></a>
<a class="sourceLine" id="array-numeric-class-4" title="4"><span class="kw">instance</span> <span class="dt">NumericType</span> <span class="dt">Float</span> <span class="kw">where</span></a>
<a class="sourceLine" id="array-numeric-class-5" title="5">    byteSize _ <span class="ot">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="array-numeric-class-6" title="6"></a>
<a class="sourceLine" id="array-numeric-class-7" title="7"><span class="kw">instance</span> <span class="dt">NumericType</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="array-numeric-class-8" title="8">    byteSize _ <span class="ot">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="array-numeric-class-9" title="9"></a>
<a class="sourceLine" id="array-numeric-class-10" title="10"><span class="kw">instance</span> (<span class="dt">NumericType</span> a) <span class="ot">=&gt;</span> <span class="dt">NumericType</span> (<span class="dt">Complex</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="array-numeric-class-11" title="11">    byteSize _ <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> (byteSize (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a))</a></code></pre></div>
<h4 id="array-structure">Array structure</h4>
<p>An array has a shape, stride and offset, in addition to a name meant to identify the array in question.</p>
<p><em>«array-types»=</em></p>
<div class="sourceCode" id="array-types"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-types-1" title="1"><span class="kw">type</span> <span class="dt">Shape</span> <span class="ot">=</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="array-types-2" title="2"><span class="kw">type</span> <span class="dt">Stride</span> <span class="ot">=</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="array-types-3" title="3"></a>
<a class="sourceLine" id="array-types-4" title="4"><span class="kw">data</span> <span class="dt">Array</span> a <span class="ot">=</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="array-types-5" title="5">    {<span class="ot"> name     ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="array-types-6" title="6">    ,<span class="ot"> shape    ::</span> <span class="dt">Shape</span></a>
<a class="sourceLine" id="array-types-7" title="7">    ,<span class="ot"> stride   ::</span> <span class="dt">Stride</span></a>
<a class="sourceLine" id="array-types-8" title="8">    ,<span class="ot"> offset   ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="array-types-9" title="9"></a>
<a class="sourceLine" id="array-types-10" title="10"><span class="co">-- data ArrayIndex a = ArrayIndex</span></a>
<a class="sourceLine" id="array-types-11" title="11"><span class="co">--    { name     :: Text</span></a>
<a class="sourceLine" id="array-types-12" title="12"><span class="co">--     , index    :: Int } deriving (Show)</span></a>
<a class="sourceLine" id="array-types-13" title="13"></a>
<a class="sourceLine" id="array-types-14" title="14"><span class="ot">floatArray ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Float</span></a>
<a class="sourceLine" id="array-types-15" title="15">floatArray name shape <span class="ot">=</span> <span class="dt">Array</span> name shape (fromShape shape <span class="dv">1</span>) <span class="dv">0</span></a></code></pre></div>
<p>The stride gives the distance in memory (counted in number of items, not bytes) for a step in each axis of the array. The location in memory can be computed using the dot-product,</p>
<p><span id="eq:strides" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[{\rm location} = {\rm stride} \cdot {\rm index} + {\rm offset}.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(5)</span></span> </p>
<h3 id="array-methods">Array methods</h3>
<p>Given a contiguous array of a given shape, we can compute the stride by taking the cumulative product.</p>
<p><em>«array-methods»=</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">fromShape ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stride</span></a>
<a class="sourceLine" id="array-methods-2" title="2">fromShape [] _ <span class="ot">=</span> []</a>
<a class="sourceLine" id="array-methods-3" title="3">fromShape (x<span class="op">:</span>xs) n <span class="ot">=</span> n <span class="op">:</span> fromShape xs (n <span class="op">*</span> x)</a></code></pre></div>
<h4 id="properties">Properties</h4>
<p>Basic properties of an array: size, dimension and if the array is contiguous.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">ndim ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="array-methods-2" title="2">ndim <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> shape</a>
<a class="sourceLine" id="array-methods-3" title="3"></a>
<a class="sourceLine" id="array-methods-4" title="4"><span class="ot">contiguous ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="array-methods-5" title="5">contiguous <span class="dt">Array</span>{shape,stride} <span class="ot">=</span> stride <span class="op">==</span> fromShape shape (<span class="fu">head</span> stride)</a></code></pre></div>
<h4 id="error-handling">Error handling</h4>
<p>Methods that can fail will return a type <code>Either Text a</code>. Since that type implements the <code>MonadError</code> class we can throw errors using <code>throwError</code> and at success <code>return</code> a value. We can generalize this pattern by accepting just any <code>MonadError Text</code> type.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">rcheck ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="array-methods-2" title="2">rcheck what n i</a>
<a class="sourceLine" id="array-methods-3" title="3">    <span class="op">|</span> (i <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">&amp;&amp;</span> (i <span class="op">&lt;</span> n) <span class="ot">=</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="array-methods-4" title="4">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> throwError <span class="op">$</span> <span class="st">&quot;Range check error: &quot;</span> <span class="op">&lt;&gt;</span> what <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="array-methods-5" title="5">                      <span class="op">&lt;&gt;</span> tshow n <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow i</a></code></pre></div>
<p>The <code>rcheck</code> function implements a range-check on the range <code>0 .. (n-1)</code>.</p>
<h4 id="reshaping-slicing">Reshaping, slicing</h4>
<p>If we have an array of complex values, we want to read out the real and imaginary parts.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">realPart ::</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> a</a>
<a class="sourceLine" id="array-methods-2" title="2">realPart array<span class="op">@</span><span class="dt">Array</span>{stride} <span class="ot">=</span> array</a>
<a class="sourceLine" id="array-methods-3" title="3">    { stride <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span> <span class="dv">2</span>) stride }</a>
<a class="sourceLine" id="array-methods-4" title="4"></a>
<a class="sourceLine" id="array-methods-5" title="5"><span class="ot">imagPart ::</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> a</a>
<a class="sourceLine" id="array-methods-6" title="6">imagPart array<span class="op">@</span><span class="dt">Array</span>{stride, offset} <span class="ot">=</span> array</a>
<a class="sourceLine" id="array-methods-7" title="7">    { stride <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span> <span class="dv">2</span>) stride</a>
<a class="sourceLine" id="array-methods-8" title="8">    , offset <span class="ot">=</span> offset <span class="op">+</span> <span class="dv">1</span> }</a></code></pre></div>
<p>Transposing an array means reversing the shape and stride vectors</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">transpose ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> a</a>
<a class="sourceLine" id="array-methods-2" title="2">transpose array<span class="op">@</span><span class="dt">Array</span>{shape, stride} <span class="ot">=</span> array</a>
<a class="sourceLine" id="array-methods-3" title="3">    { shape <span class="ot">=</span> <span class="fu">reverse</span> shape</a>
<a class="sourceLine" id="array-methods-4" title="4">    , stride <span class="ot">=</span> <span class="fu">reverse</span> stride }</a></code></pre></div>
<p>Reshaping is only possible from an array that can be flattened to a one-dimensional array with constant stride. Otherwise the arithmetic of stepping through the resulting array would no longer be expressible in terms of a stride and offset.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">reshape ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</a>
<a class="sourceLine" id="array-methods-2" title="2">reshape newShape array</a>
<a class="sourceLine" id="array-methods-3" title="3">    <span class="op">|</span> (ndim array) <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> array</a>
<a class="sourceLine" id="array-methods-4" title="4">        { shape <span class="ot">=</span> newShape</a>
<a class="sourceLine" id="array-methods-5" title="5">        , stride <span class="ot">=</span> fromShape newShape (<span class="fu">head</span> <span class="op">$</span> stride array) }</a>
<a class="sourceLine" id="array-methods-6" title="6">    <span class="op">|</span> contiguous array <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> array</a>
<a class="sourceLine" id="array-methods-7" title="7">        { shape <span class="ot">=</span> newShape</a>
<a class="sourceLine" id="array-methods-8" title="8">        , stride <span class="ot">=</span> fromShape newShape <span class="dv">1</span> }</a>
<a class="sourceLine" id="array-methods-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> throwError <span class="st">&quot;Cannot reshape multi-dimensional non-contiguous array.&quot;</span></a></code></pre></div>
<p>The <code>select</code>, <code>extrude</code>, and <code>slice</code> methods do the same as the Numpy array slice notation.</p>
<table>
<thead>
<tr class="header">
<th>Numpy</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a[:,3]</code></td>
<td><code>select a 1 3</code></td>
<td>Select 4th column</td>
</tr>
<tr class="even">
<td><code>a[3:9:2,:]</code></td>
<td><code>slice a 0 3 9 2</code></td>
<td>Slice rows 4, 6 and 8</td>
</tr>
<tr class="odd">
<td><code>a[:,None,:]</code></td>
<td><code>extrude a 1</code></td>
<td>Extrude a new axis</td>
</tr>
</tbody>
</table>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="array-methods-1" title="1"><span class="ot">select ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</a>
<a class="sourceLine" id="array-methods-2" title="2">select dim i array<span class="op">@</span><span class="dt">Array</span>{shape,stride,offset} <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="array-methods-3" title="3">    rcheck <span class="st">&quot;dim&quot;</span> (ndim array) dim</a>
<a class="sourceLine" id="array-methods-4" title="4">    rcheck <span class="st">&quot;size&quot;</span> (shape <span class="op">!!</span> dim) i</a>
<a class="sourceLine" id="array-methods-5" title="5">    <span class="fu">return</span> <span class="op">$</span> array</a>
<a class="sourceLine" id="array-methods-6" title="6">        { shape  <span class="ot">=</span> remove shape dim</a>
<a class="sourceLine" id="array-methods-7" title="7">        , stride <span class="ot">=</span> remove stride dim</a>
<a class="sourceLine" id="array-methods-8" title="8">        , offset <span class="ot">=</span> offset <span class="op">+</span> (stride <span class="op">!!</span> dim) <span class="op">*</span> i }</a>
<a class="sourceLine" id="array-methods-9" title="9"></a>
<a class="sourceLine" id="array-methods-10" title="10"><span class="ot">extrude ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</a>
<a class="sourceLine" id="array-methods-11" title="11">extrude dim array<span class="op">@</span><span class="dt">Array</span>{shape,stride} <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="array-methods-12" title="12">    rcheck <span class="st">&quot;dim&quot;</span> (ndim array <span class="op">+</span> <span class="dv">1</span>) dim</a>
<a class="sourceLine" id="array-methods-13" title="13">    <span class="fu">return</span> <span class="op">$</span> array</a>
<a class="sourceLine" id="array-methods-14" title="14">        { shape  <span class="ot">=</span> insert shape dim <span class="dv">1</span></a>
<a class="sourceLine" id="array-methods-15" title="15">        , stride <span class="ot">=</span> insert stride dim ((stride <span class="op">!!</span> dim) <span class="op">*</span> (shape <span class="op">!!</span> dim)) }</a>
<a class="sourceLine" id="array-methods-16" title="16"></a>
<a class="sourceLine" id="array-methods-17" title="17"><span class="ot">slice ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</a>
<a class="sourceLine" id="array-methods-18" title="18">slice dim a b step array<span class="op">@</span><span class="dt">Array</span>{shape,stride,offset} <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="array-methods-19" title="19">    rcheck <span class="st">&quot;dim&quot;</span> (ndim array) dim</a>
<a class="sourceLine" id="array-methods-20" title="20">    rcheck <span class="st">&quot;a&quot;</span> ((shape <span class="op">!!</span> dim) <span class="op">+</span> <span class="dv">1</span>) a</a>
<a class="sourceLine" id="array-methods-21" title="21">    rcheck <span class="st">&quot;b&quot;</span> ((shape <span class="op">!!</span> dim) <span class="op">+</span> <span class="dv">1</span>) b</a>
<a class="sourceLine" id="array-methods-22" title="22">    <span class="fu">return</span> <span class="op">$</span> array</a>
<a class="sourceLine" id="array-methods-23" title="23">        { shape  <span class="ot">=</span> replace shape  dim ((b <span class="op">-</span> a) <span class="ot">`quot`</span> step)</a>
<a class="sourceLine" id="array-methods-24" title="24">        , stride <span class="ot">=</span> replace stride dim ((stride <span class="op">!!</span> dim) <span class="op">*</span> step)</a>
<a class="sourceLine" id="array-methods-25" title="25">        , offset <span class="ot">=</span> offset <span class="op">+</span> (stride <span class="op">!!</span> dim) <span class="op">*</span> a }</a></code></pre></div>
<h2 id="codelets-and-twiddles">Codelets and Twiddles</h2>
<h3 id="codelets">Codelets</h3>
<p>A codelet, for the moment, is just some function that we can call.</p>
<p><em>file: «src/Codelet.hs»=</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">{-# LANGUAGE DataKinds,GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">module</span> <span class="dt">Codelet</span></a>
<a class="sourceLine" id="cb2-5" title="5">  ( <span class="dt">Codelet</span>(<span class="op">..</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">  , <span class="dt">CodeletType</span>(<span class="op">..</span>)</a>
<a class="sourceLine" id="cb2-7" title="7">  , codeletName</a>
<a class="sourceLine" id="cb2-8" title="8">  , <span class="dt">NoTwiddleCodelet</span></a>
<a class="sourceLine" id="cb2-9" title="9">  , <span class="dt">TwiddleCodelet</span> ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="kw">import</span> <span class="dt">AST</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">import</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb2-15" title="15"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb2-16" title="16"></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="kw">data</span> <span class="dt">CodeletType</span> <span class="ot">=</span> <span class="dt">Twiddle</span> <span class="op">|</span> <span class="dt">NoTwiddle</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">CodeletType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-20" title="20">  <span class="fu">show</span> <span class="dt">Twiddle</span> <span class="ot">=</span> <span class="st">&quot;twiddle&quot;</span></a>
<a class="sourceLine" id="cb2-21" title="21">  <span class="fu">show</span> <span class="dt">NoTwiddle</span> <span class="ot">=</span> <span class="st">&quot;notw&quot;</span></a>
<a class="sourceLine" id="cb2-22" title="22"></a>
<a class="sourceLine" id="cb2-23" title="23"><span class="kw">data</span> <span class="dt">Codelet</span> <span class="ot">=</span> <span class="dt">Codelet</span></a>
<a class="sourceLine" id="cb2-24" title="24">  {<span class="ot"> codeletType  ::</span> <span class="dt">CodeletType</span></a>
<a class="sourceLine" id="cb2-25" title="25">  ,<span class="ot"> codeletRadix ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb2-26" title="26">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb2-27" title="27"></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="ot">codeletName ::</span> <span class="dt">Codelet</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-29" title="29">codeletName <span class="dt">Codelet</span>{<span class="op">..</span>} <span class="ot">=</span> tshow codeletType <span class="op">&lt;&gt;</span> <span class="st">&quot;_&quot;</span> <span class="op">&lt;&gt;</span> tshow codeletRadix</a>
<a class="sourceLine" id="cb2-30" title="30"></a>
<a class="sourceLine" id="cb2-31" title="31"><span class="kw">type</span> <span class="dt">NoTwiddleCodelet</span> a <span class="ot">=</span> <span class="dt">Function</span></a>
<a class="sourceLine" id="cb2-32" title="32">  [ <span class="dt">Array</span> a, <span class="dt">Array</span> a</a>
<a class="sourceLine" id="cb2-33" title="33">  , <span class="dt">Array</span> a, <span class="dt">Array</span> a</a>
<a class="sourceLine" id="cb2-34" title="34">  , <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span> ] ()</a>
<a class="sourceLine" id="cb2-35" title="35"></a>
<a class="sourceLine" id="cb2-36" title="36"><span class="kw">type</span> <span class="dt">TwiddleCodelet</span> a <span class="ot">=</span> <span class="dt">Function</span></a>
<a class="sourceLine" id="cb2-37" title="37">  [ <span class="dt">Array</span> a, <span class="dt">Array</span> a</a>
<a class="sourceLine" id="cb2-38" title="38">  , <span class="dt">Array</span> a</a>
<a class="sourceLine" id="cb2-39" title="39">  , <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span> ] ()</a></code></pre></div>
<h3 id="calling-genfft">Calling GenFFT</h3>
<p>This is an interface to the GenFFT executables. The most generic function here is <code>gen</code>, which can be passed a <code>Codelet</code> and a <code>GenFFTArgs</code> value, returning the generated code as <code>IO Text</code>.</p>
<p><em>file: «src/GenFFT.hs»=</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">module</span> <span class="dt">GenFFT</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">import</span> <span class="dt">System.Process</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="kw">import</span> <span class="dt">Data.Maybe</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="kw">import</span> <span class="dt">Codelet</span> (<span class="dt">Codelet</span>(..), codeletName)</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="kw">import</span> <span class="dt">Lib</span> (tshow)</a>
<a class="sourceLine" id="cb3-12" title="12"></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="kw">class</span> <span class="dt">ValidArg</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="ot">  toText ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">String</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-17" title="17">  toText <span class="ot">=</span> T.pack</a>
<a class="sourceLine" id="cb3-18" title="18"></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Text</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-20" title="20">  toText <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb3-21" title="21"></a>
<a class="sourceLine" id="cb3-22" title="22"><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-23" title="23">  toText <span class="ot">=</span> tshow</a>
<a class="sourceLine" id="cb3-24" title="24"></a>
<a class="sourceLine" id="cb3-25" title="25"><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-26" title="26">  toText <span class="ot">=</span> tshow</a>
<a class="sourceLine" id="cb3-27" title="27"></a>
<a class="sourceLine" id="cb3-28" title="28"><span class="ot">macros ::</span> [(<span class="dt">Text</span>, <span class="dt">Text</span>)]</a>
<a class="sourceLine" id="cb3-29" title="29">macros <span class="ot">=</span></a>
<a class="sourceLine" id="cb3-30" title="30">  [ (<span class="st">&quot;R&quot;</span>,<span class="st">&quot;float&quot;</span>)</a>
<a class="sourceLine" id="cb3-31" title="31">  , (<span class="st">&quot;E&quot;</span>,<span class="st">&quot;R&quot;</span>)</a>
<a class="sourceLine" id="cb3-32" title="32">  , (<span class="st">&quot;stride&quot;</span>,<span class="st">&quot;int&quot;</span>)</a>
<a class="sourceLine" id="cb3-33" title="33">  , (<span class="st">&quot;INT&quot;</span>,<span class="st">&quot;int&quot;</span>)</a>
<a class="sourceLine" id="cb3-34" title="34">  , (<span class="st">&quot;K(x)&quot;</span>,<span class="st">&quot;((E) x)&quot;</span>)</a>
<a class="sourceLine" id="cb3-35" title="35">  , (<span class="st">&quot;DK(name,value)&quot;</span>,<span class="st">&quot;const E name = K(value)&quot;</span>)</a>
<a class="sourceLine" id="cb3-36" title="36">  , (<span class="st">&quot;WS(s,i)&quot;</span>,<span class="st">&quot;s*i&quot;</span>)</a>
<a class="sourceLine" id="cb3-37" title="37">  , (<span class="st">&quot;MAKE_VOLATILE_STRIDE(x,y)&quot;</span>,<span class="st">&quot;0&quot;</span>)</a>
<a class="sourceLine" id="cb3-38" title="38">  , (<span class="st">&quot;FMA(a,b,c)&quot;</span>,<span class="st">&quot;a * b + c&quot;</span>)</a>
<a class="sourceLine" id="cb3-39" title="39">  , (<span class="st">&quot;FMS(a,b,c)&quot;</span>,<span class="st">&quot;a * b - c&quot;</span>)</a>
<a class="sourceLine" id="cb3-40" title="40">  , (<span class="st">&quot;FNMA(a,b,c)&quot;</span>,<span class="st">&quot;-a * b - c&quot;</span>)</a>
<a class="sourceLine" id="cb3-41" title="41">  , (<span class="st">&quot;FNMS(a,b,c)&quot;</span>,<span class="st">&quot;-a * b + c&quot;</span>) ]</a>
<a class="sourceLine" id="cb3-42" title="42"></a>
<a class="sourceLine" id="cb3-43" title="43"><span class="ot">genMacros ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-44" title="44">genMacros <span class="ot">=</span> T.unlines <span class="op">$</span> <span class="fu">map</span> (\(k, v) <span class="ot">-&gt;</span> <span class="st">&quot;#define &quot;</span> <span class="op">&lt;&gt;</span> k <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> v) macros</a>
<a class="sourceLine" id="cb3-45" title="45"></a>
<a class="sourceLine" id="cb3-46" title="46"><span class="ot">genFFT ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-47" title="47">genFFT kind args <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-48" title="48">  <span class="kw">let</span> progName <span class="ot">=</span> T.unpack <span class="op">$</span> <span class="st">&quot;./genfft/gen_&quot;</span> <span class="op">&lt;&gt;</span> kind <span class="op">&lt;&gt;</span> <span class="st">&quot;.native&quot;</span></a>
<a class="sourceLine" id="cb3-49" title="49">      <span class="co">-- spec = RawCommand progName (map T.unpack args)</span></a>
<a class="sourceLine" id="cb3-50" title="50">  code <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> readProcess progName (<span class="fu">map</span> T.unpack args) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb3-51" title="51">  indent code</a>
<a class="sourceLine" id="cb3-52" title="52"></a>
<a class="sourceLine" id="cb3-53" title="53"><span class="ot">indent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-54" title="54">indent x <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> readProcess <span class="st">&quot;indent&quot;</span> [<span class="st">&quot;-nut&quot;</span>] (T.unpack x)</a>
<a class="sourceLine" id="cb3-55" title="55"></a>
<a class="sourceLine" id="cb3-56" title="56"><span class="kw">data</span> <span class="dt">GenFFTArgs</span> <span class="ot">=</span> <span class="dt">GenFFTArgs</span></a>
<a class="sourceLine" id="cb3-57" title="57">  {<span class="ot"> compact     ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-58" title="58">  ,<span class="ot"> standalone  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-59" title="59">  ,<span class="ot"> opencl      ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-60" title="60">  ,<span class="ot"> name        ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb3-61" title="61"></a>
<a class="sourceLine" id="cb3-62" title="62"><span class="ot">defaultArgs ::</span> <span class="dt">GenFFTArgs</span></a>
<a class="sourceLine" id="cb3-63" title="63">defaultArgs <span class="ot">=</span> <span class="dt">GenFFTArgs</span></a>
<a class="sourceLine" id="cb3-64" title="64">  { compact <span class="ot">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-65" title="65">  , standalone <span class="ot">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-66" title="66">  , opencl <span class="ot">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-67" title="67">  , name <span class="ot">=</span> <span class="dt">Nothing</span> }</a>
<a class="sourceLine" id="cb3-68" title="68"></a>
<a class="sourceLine" id="cb3-69" title="69"><span class="ot">optionalArg ::</span> (<span class="dt">ValidArg</span> a) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb3-70" title="70">optionalArg opt val <span class="ot">=</span> fromMaybe [] (<span class="kw">do</span> {n <span class="ot">&lt;-</span> val; <span class="fu">return</span> [opt, toText n]})</a>
<a class="sourceLine" id="cb3-71" title="71"></a>
<a class="sourceLine" id="cb3-72" title="72"><span class="ot">argList ::</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb3-73" title="73">argList <span class="dt">GenFFTArgs</span>{<span class="op">..</span>} <span class="ot">=</span></a>
<a class="sourceLine" id="cb3-74" title="74">  optionalArg <span class="st">&quot;-name&quot;</span> name</a>
<a class="sourceLine" id="cb3-75" title="75">  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-compact&quot;</span> <span class="op">|</span> compact]</a>
<a class="sourceLine" id="cb3-76" title="76">  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-standalone&quot;</span> <span class="op">|</span> standalone]</a>
<a class="sourceLine" id="cb3-77" title="77">  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-opencl&quot;</span> <span class="op">|</span> opencl]</a>
<a class="sourceLine" id="cb3-78" title="78"></a>
<a class="sourceLine" id="cb3-79" title="79"><span class="ot">genNoTwiddle ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-80" title="80">genNoTwiddle radix args <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-81" title="81">  <span class="kw">let</span> name&#39; <span class="ot">=</span> fromMaybe (<span class="st">&quot;notw_&quot;</span> <span class="op">&lt;&gt;</span> tshow radix) (name args)</a>
<a class="sourceLine" id="cb3-82" title="82">  genFFT <span class="st">&quot;notw&quot;</span> <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow radix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</a>
<a class="sourceLine" id="cb3-83" title="83"></a>
<a class="sourceLine" id="cb3-84" title="84"><span class="ot">genTwiddle ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-85" title="85">genTwiddle radix args <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-86" title="86">  <span class="kw">let</span> name&#39; <span class="ot">=</span> fromMaybe (<span class="st">&quot;twiddle_&quot;</span> <span class="op">&lt;&gt;</span> tshow radix) (name args)</a>
<a class="sourceLine" id="cb3-87" title="87">  genFFT <span class="st">&quot;twiddle&quot;</span> <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow radix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</a>
<a class="sourceLine" id="cb3-88" title="88"></a>
<a class="sourceLine" id="cb3-89" title="89"><span class="ot">gen ::</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">Codelet</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-90" title="90">gen args codelet<span class="op">@</span><span class="dt">Codelet</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-91" title="91">  <span class="kw">let</span> name&#39; <span class="ot">=</span> codeletName codelet</a>
<a class="sourceLine" id="cb3-92" title="92">  genFFT (tshow codeletType) <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow codeletRadix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</a></code></pre></div>
<h3 id="twiddle-factors">Twiddle factors</h3>
<p>In Python we created an array of twiddle factors:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> w(k, n):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="cf">return</span> np.exp(2j <span class="op">*</span> np.pi <span class="op">*</span> k <span class="op">/</span> n)</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">def</span> make_twiddle(n1, n2):</a>
<a class="sourceLine" id="cb4-5" title="5">    I1 <span class="op">=</span> np.arange(n1)</a>
<a class="sourceLine" id="cb4-6" title="6">    I2 <span class="op">=</span> np.arange(n2)</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="cf">return</span> w(I1[:,<span class="va">None</span>] <span class="op">*</span> I2[<span class="va">None</span>,:], n1<span class="op">*</span>n2).astype(<span class="st">&#39;complex64&#39;</span>)</a></code></pre></div>
<p>In Haskell this is a bit different:</p>
<p><em>file: «src/TwiddleFactors.hs»=</em></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">module</span> <span class="dt">TwiddleFactors</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="dt">Data.Complex</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> (<span class="dt">Vector</span>)</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="kw">import</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>w<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>multi<span class="op">-</span>w<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>make<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb5-16" title="16"></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="ot">factorsName ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-18" title="18">factorsName s <span class="ot">=</span> <span class="st">&quot;w_&quot;</span> <span class="op">&lt;&gt;</span> T.intercalate <span class="st">&quot;_&quot;</span> (<span class="fu">map</span> tshow s)</a></code></pre></div>
<p>We still have the equation</p>
<p><span class="math display">\[w_n^k = \exp \left[2 \pi i \frac{k}{n}\right].\]</span></p>
<p>Haskell provides the function <code>cis</code> which computes a complex point on the unit circle given the phase.</p>
<p><em>«twiddle-factors-w»=</em></p>
<div class="sourceCode" id="twiddle-factors-w"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="twiddle-factors-w-1" title="1"><span class="ot">w ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</a>
<a class="sourceLine" id="twiddle-factors-w-2" title="2">w n k <span class="ot">=</span> cis (<span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> <span class="fu">fromIntegral</span> k <span class="op">/</span> <span class="fu">fromIntegral</span> n)</a></code></pre></div>
<p>We need to map the index vector to a value <span class="math inline">\(w_{\prod n_i}^{\prod k_i}\)</span>.</p>
<p><em>«twiddle-factors-multi-w»=</em></p>
<div class="sourceCode" id="twiddle-factors-multi-w"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="twiddle-factors-multi-w-1" title="1"><span class="ot">multiW ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</a>
<a class="sourceLine" id="twiddle-factors-multi-w-2" title="2">multiW n k <span class="ot">=</span> w (<span class="fu">product</span> n) (<span class="fu">product</span> k)</a></code></pre></div>
<p>To generate the list of indices (lists are lazy, so this should be efficient enough), we have a nifty one-liner. Given a list of indices for a reduced shape vector we can create the full list by prepending numbers from the range <code>[0 .. n-1]</code>.</p>
<p><em>«twiddle-factors-make»=</em></p>
<div class="sourceCode" id="twiddle-factors-make"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="twiddle-factors-make-1" title="1"><span class="ot">indices ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="twiddle-factors-make-2" title="2">indices <span class="ot">=</span> <span class="fu">foldr</span> (\ n <span class="ot">-&gt;</span> <span class="fu">concatMap</span> (\ idcs <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">:</span> idcs) [<span class="dv">0</span> <span class="op">..</span> n<span class="op">-</span><span class="dv">1</span>])) [[]]</a>
<a class="sourceLine" id="twiddle-factors-make-3" title="3"></a>
<a class="sourceLine" id="twiddle-factors-make-4" title="4"><span class="ot">makeTwiddle ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">Complex</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="twiddle-factors-make-5" title="5">makeTwiddle shape <span class="ot">=</span> V.drop (<span class="fu">head</span> shape) <span class="op">$</span> V.fromList <span class="op">$</span> <span class="fu">map</span> (multiW shape) <span class="op">$</span> indices shape</a></code></pre></div>
<h3 id="unit-tests">Unit tests</h3>
<p><em>«test-predicates»=</em></p>
<div class="sourceCode" id="test-predicates"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="test-predicates-1" title="1"><span class="kw">class</span> <span class="dt">Approx</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="test-predicates-2" title="2"><span class="ot">    closeTo ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="test-predicates-3" title="3"></a>
<a class="sourceLine" id="test-predicates-4" title="4"><span class="kw">instance</span> <span class="dt">Approx</span> <span class="dt">Float</span> <span class="kw">where</span></a>
<a class="sourceLine" id="test-predicates-5" title="5">    closeTo a b <span class="ot">=</span> <span class="fu">abs</span> (a <span class="op">-</span> b) <span class="op">&lt;</span> <span class="fl">1e-5</span></a>
<a class="sourceLine" id="test-predicates-6" title="6"></a>
<a class="sourceLine" id="test-predicates-7" title="7"><span class="kw">instance</span> <span class="dt">Approx</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="test-predicates-8" title="8">    closeTo a b <span class="ot">=</span> <span class="fu">abs</span> (a <span class="op">-</span> b) <span class="op">&lt;</span> <span class="fl">1e-10</span></a>
<a class="sourceLine" id="test-predicates-9" title="9"></a>
<a class="sourceLine" id="test-predicates-10" title="10"><span class="kw">instance</span> (<span class="dt">Approx</span> a, <span class="dt">Applicative</span> m, <span class="dt">Foldable</span> m) <span class="ot">=&gt;</span> <span class="dt">Approx</span> (m a) <span class="kw">where</span></a>
<a class="sourceLine" id="test-predicates-11" title="11">    closeTo x y <span class="ot">=</span> <span class="fu">and</span> <span class="op">$</span> liftA2 closeTo x y</a>
<a class="sourceLine" id="test-predicates-12" title="12"></a>
<a class="sourceLine" id="test-predicates-13" title="13"><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> (<span class="dt">Approx</span> a, <span class="dt">V.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">Approx</span> (<span class="dt">Vector</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="test-predicates-14" title="14">    closeTo x y <span class="ot">=</span> V.and <span class="op">$</span> V.zipWith closeTo x y</a></code></pre></div>
<p><em>«test-twiddle-factors»=</em></p>
<div class="sourceCode" id="test-twiddle-factors"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="test-twiddle-factors-1" title="1">describe <span class="st">&quot;TwiddleFactors.indices&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="test-twiddle-factors-2" title="2">    it <span class="st">&quot;creates an index list&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="test-twiddle-factors-3" title="3">        indices [<span class="dv">2</span>, <span class="dv">2</span>] <span class="ot">`shouldBe`</span> [[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>]]</a>
<a class="sourceLine" id="test-twiddle-factors-4" title="4">        indices [<span class="dv">3</span>, <span class="dv">1</span>] <span class="ot">`shouldBe`</span> [[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">0</span>]]</a>
<a class="sourceLine" id="test-twiddle-factors-5" title="5"></a>
<a class="sourceLine" id="test-twiddle-factors-6" title="6">describe <span class="st">&quot;TwiddleFactors.makeTwiddle&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="test-twiddle-factors-7" title="7">    it <span class="st">&quot;Generates twiddle factors&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="test-twiddle-factors-8" title="8">        makeTwiddle [<span class="dv">2</span>, <span class="dv">2</span>] <span class="ot">`shouldSatisfy`</span> closeTo</a>
<a class="sourceLine" id="test-twiddle-factors-9" title="9">            (V.fromList [ <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> <span class="fl">1.0</span> ])</a>
<a class="sourceLine" id="test-twiddle-factors-10" title="10">        makeTwiddle [<span class="dv">4</span>] <span class="ot">`shouldSatisfy`</span> closeTo</a>
<a class="sourceLine" id="test-twiddle-factors-11" title="11">            (V.fromList [ <span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> <span class="fl">1.0</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> (<span class="op">-</span><span class="fl">1.0</span>) ])</a></code></pre></div>
<h2 id="abstract-syntax-tree">Abstract Syntax Tree</h2>
<p>To synthesise a larger FFT we have to duplicate some of the work done in GenFFT. We’ll describe calling the codelets and the matching loop structure in terms of an <em>abstract syntax tree</em>. The AST will contain a subset of OpenCL focussed on computing FFTs.</p>
<p>Describing code structure is somewhat of a specialty of Haskell. Modern Haskell has features to describe syntax trees that are completely type safe, meaning that any expression where the types to not match up (for instance between function parameters, and applied arguments) is ill-formed to the point that they’re impossible to construct. We need a few language extensions to make this work:</p>
<p><em>«ast-haskell-extensions»=</em></p>
<div class="sourceCode" id="ast-haskell-extensions"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-haskell-extensions-1" title="1"><span class="ot">{-# LANGUAGE GADTs,DataKinds,TypeOperators,KindSignatures #-}</span></a>
<a class="sourceLine" id="ast-haskell-extensions-2" title="2"><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></a>
<a class="sourceLine" id="ast-haskell-extensions-3" title="3"><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></a>
<a class="sourceLine" id="ast-haskell-extensions-4" title="4"><span class="ot">{-# LANGUAGE FlexibleInstances,UndecidableInstances #-}</span></a></code></pre></div>
<h3 id="type-lists">Type lists</h3>
<p>We need a way to declare the list of argument types to the codelets. In standard haskell this can be done by defining a recursive data-type, but the syntax would be ugly with lots of nested type expressions. The <code>DataKinds</code> and <code>TypeOperators</code> extensions let us define a type-level list structure and express it using normal list syntax (sometimes prefixed with a quote to disambiguate with data-level lists).</p>
<p><em>«ast-typelists»=</em></p>
<div class="sourceCode" id="ast-typelists"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-typelists-1" title="1"><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-typelists-2" title="2">    <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> &#39;[]</a>
<a class="sourceLine" id="ast-typelists-3" title="3">    <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HList</span> l <span class="ot">-&gt;</span> <span class="dt">HList</span> (a &#39;<span class="op">:</span> l)</a>
<a class="sourceLine" id="ast-typelists-4" title="4"></a>
<a class="sourceLine" id="ast-typelists-5" title="5"><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">HList</span> &#39;[]) <span class="kw">where</span></a>
<a class="sourceLine" id="ast-typelists-6" title="6">    <span class="fu">show</span> <span class="dt">Nil</span> <span class="ot">=</span> <span class="st">&quot;Nil&quot;</span></a>
<a class="sourceLine" id="ast-typelists-7" title="7"></a>
<a class="sourceLine" id="ast-typelists-8" title="8"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> (<span class="dt">HList</span> l)) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">HList</span> (a &#39;<span class="op">:</span> l)) <span class="kw">where</span></a>
<a class="sourceLine" id="ast-typelists-9" title="9">    <span class="fu">show</span> (<span class="dt">Cons</span> x xs) <span class="ot">=</span> <span class="st">&quot;Cons &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; (&quot;</span> <span class="op">++</span> <span class="fu">show</span> xs <span class="op">++</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<h3 id="opencl-namespaces">OpenCL namespaces</h3>
<p>OpenCL has several namespaces for different kinds of memory: <code>__constant</code>, <code>__global</code> and <code>__static</code> (there may be more, I don’t know).</p>
<p><em>«ast-ocl-namespaces»=</em></p>
<div class="sourceCode" id="ast-ocl-namespaces"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-ocl-namespaces-1" title="1"><span class="kw">data</span> <span class="dt">NameSpace</span> <span class="ot">=</span> <span class="dt">Static</span> <span class="op">|</span> <span class="dt">Global</span> <span class="op">|</span> <span class="dt">Constant</span></a></code></pre></div>
<h3 id="basic-types">Basic types</h3>
<p>Many of the types that we define here exist just as type-level tags to larger expressions</p>
<p><em>«ast-basic-types»=</em></p>
<div class="sourceCode" id="ast-basic-types"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-basic-types-1" title="1"><span class="kw">class</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Declarable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="ast-basic-types-2" title="2"><span class="ot">  typename ::</span> proxy a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="ast-basic-types-3" title="3"></a>
<a class="sourceLine" id="ast-basic-types-4" title="4"><span class="kw">data</span> <span class="dt">Pointer</span> a <span class="ot">=</span> <span class="dt">Pointer</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="ast-basic-types-5" title="5"><span class="kw">data</span> <span class="dt">Function</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-basic-types-6" title="6">  <span class="dt">Function</span><span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Function</span> a b</a>
<a class="sourceLine" id="ast-basic-types-7" title="7">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="ast-basic-types-8" title="8"><span class="kw">newtype</span> <span class="dt">Variable</span> a <span class="ot">=</span> <span class="dt">Variable</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="ast-basic-types-9" title="9"></a>
<a class="sourceLine" id="ast-basic-types-10" title="10"><span class="kw">instance</span> <span class="dt">Declarable</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-basic-types-11" title="11">  typename _ <span class="ot">=</span> <span class="st">&quot;int&quot;</span></a>
<a class="sourceLine" id="ast-basic-types-12" title="12"><span class="kw">instance</span> <span class="dt">Declarable</span> <span class="dt">Double</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-basic-types-13" title="13">  typename _ <span class="ot">=</span> <span class="st">&quot;R&quot;</span></a>
<a class="sourceLine" id="ast-basic-types-14" title="14"><span class="kw">instance</span> <span class="dt">Declarable</span> a <span class="ot">=&gt;</span> <span class="dt">Declarable</span> (<span class="dt">Pointer</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="ast-basic-types-15" title="15">  typename _ <span class="ot">=</span> typename (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="op">&lt;&gt;</span> <span class="st">&quot;*&quot;</span></a></code></pre></div>
<h3 id="expressions">Expressions</h3>
<p>An expression is any unit of code that can be said to have some value. Expressions can be arguments to functions, or they can assigned to a variable.</p>
<p><em>«ast-expression»=</em></p>
<div class="sourceCode" id="ast-expression"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-expression-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="ast-expression-2" title="2">    <span class="dt">Literal</span><span class="ot">        ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="ast-expression-3" title="3">    <span class="dt">IntegerValue</span><span class="ot">   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="ast-expression-4" title="4">    <span class="dt">RealValue</span><span class="ot">      ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="ast-expression-5" title="5">    <span class="dt">ArrayRef</span><span class="ot">       ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Array</span> a)</a>
<a class="sourceLine" id="ast-expression-6" title="6">    <span class="dt">VarReference</span><span class="ot">   ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="ast-expression-7" title="7">    <span class="dt">ArrayIndex</span><span class="ot">     ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> [<span class="dt">Expr</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="ast-expression-8" title="8">    <span class="dt">TUnit</span><span class="ot">          ::</span> <span class="dt">Expr</span> ()</a>
<a class="sourceLine" id="ast-expression-9" title="9">    <span class="dt">TNull</span><span class="ot">          ::</span> <span class="dt">Expr</span> (<span class="dt">HList</span> &#39;[])</a>
<a class="sourceLine" id="ast-expression-10" title="10"><span class="ot">    (:+:)          ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">HList</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">HList</span> (a &#39;<span class="op">:</span> b))</a>
<a class="sourceLine" id="ast-expression-11" title="11">    <span class="dt">Apply</span><span class="ot">          ::</span> <span class="dt">Function</span> a b <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">HList</span> a) <span class="ot">-&gt;</span> <span class="dt">Expr</span> b</a>
<a class="sourceLine" id="ast-expression-12" title="12"></a>
<a class="sourceLine" id="ast-expression-13" title="13"><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">:+:</span></a></code></pre></div>
<p>The most important entries here are <code>(:+:)</code> and <code>Apply</code>. The <code>:+:</code> operator is used to construct an argument list. This argument list can then be applied to a function using <code>Apply</code>. As an example, here is the definition of <code>planNoTwiddle</code>. This function builds the AST for calling a no-twiddle FFT codelet, given an input and output array.</p>
<p><em>«synth-planNoTwiddle»=</em></p>
<div class="sourceCode" id="synth-planNoTwiddle"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="synth-planNoTwiddle-1" title="1"><span class="ot">planNoTwiddle ::</span> (<span class="dt">MonadError</span> <span class="dt">Text</span> m, <span class="dt">RealFloat</span> a) <span class="ot">=&gt;</span> <span class="dt">NoTwiddleCodelet</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Expr</span> ())</a>
<a class="sourceLine" id="synth-planNoTwiddle-2" title="2">planNoTwiddle f inp out <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-3" title="3">  is  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">0</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-4" title="4">  os  <span class="ot">&lt;-</span> stride out <span class="op">!?</span> <span class="dv">0</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-5" title="5">  v   <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-6" title="6">  ivs <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-7" title="7">  ovs <span class="ot">&lt;-</span> stride out <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-8" title="8">  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Apply</span> f (<span class="dt">ArrayRef</span> (realPart inp) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart inp) <span class="op">:+:</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-9" title="9">                    <span class="dt">ArrayRef</span> (realPart out) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart out) <span class="op">:+:</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-10" title="10">                    <span class="dt">Literal</span> is <span class="op">:+:</span> <span class="dt">Literal</span> os <span class="op">:+:</span> <span class="dt">Literal</span> v <span class="op">:+:</span> <span class="dt">Literal</span> ivs <span class="op">:+:</span></a>
<a class="sourceLine" id="synth-planNoTwiddle-11" title="11">                    <span class="dt">Literal</span> ovs <span class="op">:+:</span> <span class="dt">TNull</span>)</a></code></pre></div>
<p>Note that the argument list is finalized with a <code>TNull</code>, otherwise the argument list would be improper.</p>
<p><em>«ast-statements»=</em></p>
<div class="sourceCode" id="ast-statements"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-statements-1" title="1"><span class="kw">data</span> <span class="dt">Range</span> <span class="ot">=</span> <span class="dt">Range</span></a>
<a class="sourceLine" id="ast-statements-2" title="2">    {<span class="ot"> start ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="ast-statements-3" title="3">    ,<span class="ot"> end   ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="ast-statements-4" title="4">    ,<span class="ot"> step  ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="ast-statements-5" title="5"></a>
<a class="sourceLine" id="ast-statements-6" title="6"></a>
<a class="sourceLine" id="ast-statements-7" title="7"><span class="kw">data</span> <span class="dt">Stmt</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-statements-8" title="8">    <span class="dt">VarDeclaration</span><span class="ot">   ::</span> (<span class="dt">Declarable</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Stmt</span></a>
<a class="sourceLine" id="ast-statements-9" title="9">    <span class="dt">Expression</span><span class="ot">       ::</span> <span class="dt">Expr</span> () <span class="ot">-&gt;</span> <span class="dt">Stmt</span></a>
<a class="sourceLine" id="ast-statements-10" title="10">    <span class="dt">ParallelFor</span><span class="ot">      ::</span> <span class="dt">Variable</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> [<span class="dt">Stmt</span>] <span class="ot">-&gt;</span> <span class="dt">Stmt</span></a>
<a class="sourceLine" id="ast-statements-11" title="11">    <span class="dt">Assignment</span><span class="ot">       ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Stmt</span></a>
<a class="sourceLine" id="ast-statements-12" title="12">    <span class="co">-- FunctionDef      :: Function a b -&gt; [Stmt] -&gt; [Stmt] -&gt; Stmt</span></a></code></pre></div>
<h3 id="generating-code">Generating code</h3>
<p>Now we can generate C/OpenCL from our AST.</p>
<p><em>«ast-syntax»=</em></p>
<div class="sourceCode" id="ast-syntax"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="ast-syntax-1" title="1"><span class="kw">class</span> <span class="dt">Syntax</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="ast-syntax-2" title="2"><span class="ot">  generate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="ast-syntax-3" title="3"></a>
<a class="sourceLine" id="ast-syntax-4" title="4"><span class="kw">instance</span> <span class="dt">Syntax</span> (<span class="dt">Expr</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="ast-syntax-5" title="5">  generate (<span class="dt">Literal</span> x) <span class="ot">=</span> tshow x</a>
<a class="sourceLine" id="ast-syntax-6" title="6">  generate (<span class="dt">IntegerValue</span> x) <span class="ot">=</span> tshow x</a>
<a class="sourceLine" id="ast-syntax-7" title="7">  generate (<span class="dt">RealValue</span> x) <span class="ot">=</span> tshow x</a>
<a class="sourceLine" id="ast-syntax-8" title="8">  generate (<span class="dt">ArrayRef</span> x)</a>
<a class="sourceLine" id="ast-syntax-9" title="9">    <span class="op">|</span> (offset x) <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> name x</a>
<a class="sourceLine" id="ast-syntax-10" title="10">    <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">=</span> name x <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> tshow (offset x)</a>
<a class="sourceLine" id="ast-syntax-11" title="11">  generate (<span class="dt">VarReference</span> (<span class="dt">Variable</span> x)) <span class="ot">=</span> x</a>
<a class="sourceLine" id="ast-syntax-12" title="12">  generate (<span class="dt">ArrayIndex</span> a i) <span class="ot">=</span> name a <span class="op">&lt;&gt;</span> <span class="st">&quot;[&lt;index expression&gt;]&quot;</span></a>
<a class="sourceLine" id="ast-syntax-13" title="13">  generate (<span class="dt">Apply</span> (<span class="dt">Function</span> f) a) <span class="ot">=</span> f <span class="op">&lt;&gt;</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> generate a <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="ast-syntax-14" title="14">  generate (a <span class="op">:+:</span> <span class="dt">TNull</span>) <span class="ot">=</span> generate a</a>
<a class="sourceLine" id="ast-syntax-15" title="15">  generate (a <span class="op">:+:</span> b) <span class="ot">=</span> generate a <span class="op">&lt;&gt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&gt;</span> generate b</a>
<a class="sourceLine" id="ast-syntax-16" title="16">  generate <span class="dt">TNull</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="ast-syntax-17" title="17">  generate <span class="dt">TUnit</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="ast-syntax-18" title="18"></a>
<a class="sourceLine" id="ast-syntax-19" title="19"><span class="kw">instance</span> <span class="dt">Syntax</span> <span class="dt">Stmt</span> <span class="kw">where</span></a>
<a class="sourceLine" id="ast-syntax-20" title="20">  generate (<span class="dt">VarDeclaration</span> v<span class="op">@</span>(<span class="dt">Variable</span> x)) <span class="ot">=</span> typename v <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></a>
<a class="sourceLine" id="ast-syntax-21" title="21">  generate (<span class="dt">Expression</span> e) <span class="ot">=</span> generate e <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></a>
<a class="sourceLine" id="ast-syntax-22" title="22">  generate (<span class="dt">ParallelFor</span> (<span class="dt">Variable</span> v) (<span class="dt">Range</span> a b s) body) <span class="ot">=</span></a>
<a class="sourceLine" id="ast-syntax-23" title="23">    <span class="st">&quot;for (int &quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;=&quot;</span> <span class="op">&lt;&gt;</span> tshow a <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;&quot;</span></a>
<a class="sourceLine" id="ast-syntax-24" title="24">    <span class="op">&lt;&gt;</span> tshow b <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;+=&quot;</span> <span class="op">&lt;&gt;</span> tshow s <span class="op">&lt;&gt;</span> <span class="st">&quot;) {\n&quot;</span></a>
<a class="sourceLine" id="ast-syntax-25" title="25">    <span class="op">&lt;&gt;</span> T.unlines (<span class="fu">map</span> generate body) <span class="op">&lt;&gt;</span> <span class="st">&quot;\n}&quot;</span></a>
<a class="sourceLine" id="ast-syntax-26" title="26">  generate (<span class="dt">Assignment</span> (<span class="dt">Variable</span> v) e) <span class="ot">=</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot; = &quot;</span> <span class="op">&lt;&gt;</span> generate e <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></a></code></pre></div>
<h3 id="ast-module">AST Module</h3>
<p><em>file: «src/AST.hs»=</em></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>haskell<span class="op">-</span>extensions<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">module</span> <span class="dt">AST</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">import</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>ocl<span class="op">-</span>namespaces<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>basic<span class="op">-</span>types<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>typelists<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>expression<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>statements<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18"><span class="kw">data</span> <span class="dt">FunctionDecl</span> a b <span class="ot">=</span> <span class="dt">FunctionDecl</span></a>
<a class="sourceLine" id="cb6-19" title="19">  {<span class="ot"> functionName ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-20" title="20">  ,<span class="ot"> argNames     ::</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb6-21" title="21">  ,<span class="ot"> functionBody ::</span> [<span class="dt">Stmt</span>] }</a>
<a class="sourceLine" id="cb6-22" title="22"></a>
<a class="sourceLine" id="cb6-23" title="23"><span class="op">&lt;&lt;</span>ast<span class="op">-</span>syntax<span class="op">&gt;&gt;</span></a></code></pre></div>
<h2 id="synthesis-of-fft">Synthesis of FFT</h2>
<p>When discussing expressions in the abstract syntax tree, the definition of <code>planNoTwiddle</code> was shown. Similarly the twiddle codelet:</p>
<p><em>«synth-planTwiddle»=</em></p>
<div class="sourceCode" id="synth-planTwiddle"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="synth-planTwiddle-1" title="1"><span class="ot">planTwiddle ::</span> (<span class="dt">MonadError</span> <span class="dt">Text</span> m, <span class="dt">RealFloat</span> a) <span class="ot">=&gt;</span> <span class="dt">TwiddleCodelet</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Expr</span> ())</a>
<a class="sourceLine" id="synth-planTwiddle-2" title="2">planTwiddle f inp twiddle <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="synth-planTwiddle-3" title="3">  rs  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">0</span></a>
<a class="sourceLine" id="synth-planTwiddle-4" title="4">  me  <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="synth-planTwiddle-5" title="5">  ms  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="synth-planTwiddle-6" title="6">  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Apply</span> f (<span class="dt">ArrayRef</span> (realPart inp) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart inp) <span class="op">:+:</span></a>
<a class="sourceLine" id="synth-planTwiddle-7" title="7">                    <span class="dt">ArrayRef</span> (realPart twiddle) <span class="op">:+:</span> <span class="dt">Literal</span> rs <span class="op">:+:</span> <span class="dt">Literal</span> <span class="dv">0</span> <span class="op">:+:</span> <span class="dt">Literal</span> me <span class="op">:+:</span> <span class="dt">Literal</span> ms <span class="op">:+:</span> <span class="dt">TNull</span>)</a></code></pre></div>
<h3 id="algorithm">Algorithm</h3>
<p>An FFT algorithm now is a collection of codelets, twiddle factors and a list of statements defining how to synthesise the larger FFT.</p>
<p><em>«synth-algorithm»=</em></p>
<div class="sourceCode" id="synth-algorithm"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="synth-algorithm-1" title="1"><span class="kw">data</span> <span class="dt">Algorithm</span> <span class="ot">=</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="synth-algorithm-2" title="2">  {<span class="ot"> codelets   ::</span> <span class="dt">Set</span> <span class="dt">Codelet</span></a>
<a class="sourceLine" id="synth-algorithm-3" title="3">  ,<span class="ot"> twiddles   ::</span> <span class="dt">Set</span> <span class="dt">Shape</span></a>
<a class="sourceLine" id="synth-algorithm-4" title="4">  ,<span class="ot"> statements ::</span> [<span class="dt">Stmt</span>] }</a></code></pre></div>
<p>To build up an algorithm from pieces, we derive an instance of <code>Monoid</code> for both <code>Algorithm</code> and <code>Either Text Algorithm</code>, the latter handling errors during code generation. We can use the <code>&lt;&gt;</code> operator to take the union of the sets of codelets and twiddles, as well as appending to the list of statements.</p>
<p><em>«synth-algorithm»=+</em></p>
<div class="sourceCode" id="synth-algorithm"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="synth-algorithm-1" title="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Algorithm</span> <span class="kw">where</span></a>
<a class="sourceLine" id="synth-algorithm-2" title="2">  (<span class="dt">Algorithm</span> c1 t1 s1) <span class="op">&lt;&gt;</span> (<span class="dt">Algorithm</span> c2 t2 s2) <span class="ot">=</span> <span class="dt">Algorithm</span> (c1 <span class="op">&lt;&gt;</span> c2) (t1 <span class="op">&lt;&gt;</span> t2) (s1 <span class="op">&lt;&gt;</span> s2)</a>
<a class="sourceLine" id="synth-algorithm-3" title="3"></a>
<a class="sourceLine" id="synth-algorithm-4" title="4"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Algorithm</span> <span class="kw">where</span></a>
<a class="sourceLine" id="synth-algorithm-5" title="5">  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Algorithm</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="synth-algorithm-6" title="6"></a>
<a class="sourceLine" id="synth-algorithm-7" title="7"><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">Semigroup</span> (<span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="synth-algorithm-8" title="8">  (<span class="dt">Left</span> a) <span class="op">&lt;&gt;</span> _ <span class="ot">=</span> <span class="dt">Left</span> a</a>
<a class="sourceLine" id="synth-algorithm-9" title="9">  _ <span class="op">&lt;&gt;</span> (<span class="dt">Left</span> b) <span class="ot">=</span> <span class="dt">Left</span> b</a>
<a class="sourceLine" id="synth-algorithm-10" title="10">  (<span class="dt">Right</span> a) <span class="op">&lt;&gt;</span> (<span class="dt">Right</span> b) <span class="ot">=</span> <span class="dt">Right</span> (a <span class="op">&lt;&gt;</span> b)</a>
<a class="sourceLine" id="synth-algorithm-11" title="11"></a>
<a class="sourceLine" id="synth-algorithm-12" title="12"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="synth-algorithm-13" title="13">  <span class="fu">mempty</span> <span class="ot">=</span> <span class="fu">return</span> <span class="fu">mempty</span></a></code></pre></div>
<h3 id="synthesis-module">Synthesis Module</h3>
<p><em>file: «src/Synthesis.hs»=</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE DataKinds,GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="kw">module</span> <span class="dt">Synthesis</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">import</span> <span class="dt">Data.Complex</span> (<span class="dt">Complex</span>(..))</a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">-- import qualified Data.Text as T</span></a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</a>
<a class="sourceLine" id="cb7-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="kw">import</span> <span class="dt">Data.List</span> (sort)</a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16"><span class="kw">import</span> <span class="dt">AST</span></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="kw">import</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></a>
<a class="sourceLine" id="cb7-20" title="20"><span class="kw">import</span> <span class="dt">Codelet</span></a>
<a class="sourceLine" id="cb7-21" title="21"><span class="kw">import</span> <span class="dt">TwiddleFactors</span></a>
<a class="sourceLine" id="cb7-22" title="22"></a>
<a class="sourceLine" id="cb7-23" title="23"><span class="kw">import</span> <span class="dt">Math.NumberTheory.Primes.Factorisation</span> (factorise)</a>
<a class="sourceLine" id="cb7-24" title="24"></a>
<a class="sourceLine" id="cb7-25" title="25"><span class="ot">(!?) ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb7-26" title="26">[] <span class="op">!?</span> i <span class="ot">=</span> throwError <span class="op">$</span> <span class="st">&quot;List index error: list &quot;</span> <span class="op">&lt;&gt;</span> tshow (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">&lt;&gt;</span> <span class="st">&quot; too short.&quot;</span></a>
<a class="sourceLine" id="cb7-27" title="27">(x<span class="op">:</span>xs) <span class="op">!?</span> i</a>
<a class="sourceLine" id="cb7-28" title="28">  <span class="op">|</span> i <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">return</span> x</a>
<a class="sourceLine" id="cb7-29" title="29">  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> xs <span class="op">!?</span> (i <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-30" title="30"></a>
<a class="sourceLine" id="cb7-31" title="31"><span class="op">&lt;&lt;</span>synth<span class="op">-</span>planNoTwiddle<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb7-32" title="32"><span class="op">&lt;&lt;</span>synth<span class="op">-</span>planTwiddle<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb7-33" title="33"><span class="op">&lt;&lt;</span>synth<span class="op">-</span>algorithm<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb7-34" title="34"></a>
<a class="sourceLine" id="cb7-35" title="35"><span class="ot">defineTwiddles ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="cb7-36" title="36">defineTwiddles shape <span class="ot">=</span> <span class="dt">Algorithm</span> <span class="fu">mempty</span> (S.fromList [shape]) <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb7-37" title="37"></a>
<a class="sourceLine" id="cb7-38" title="38"><span class="ot">noTwiddleFFT ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="cb7-39" title="39">noTwiddleFFT n inp out <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-40" title="40">  <span class="kw">let</span> codelet <span class="ot">=</span> <span class="dt">Codelet</span> <span class="dt">NoTwiddle</span> n</a>
<a class="sourceLine" id="cb7-41" title="41">      f <span class="ot">=</span> <span class="dt">Function</span> (codeletName codelet)<span class="ot"> ::</span> <span class="dt">NoTwiddleCodelet</span> a</a>
<a class="sourceLine" id="cb7-42" title="42">  plan <span class="ot">&lt;-</span> planNoTwiddle f inp out</a>
<a class="sourceLine" id="cb7-43" title="43">  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Algorithm</span> (S.fromList [codelet]) <span class="fu">mempty</span> [<span class="dt">Expression</span> plan]</a>
<a class="sourceLine" id="cb7-44" title="44"></a>
<a class="sourceLine" id="cb7-45" title="45"><span class="ot">twiddleFFT ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="cb7-46" title="46">twiddleFFT n inp twiddle <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-47" title="47">  <span class="kw">let</span> codelet <span class="ot">=</span> <span class="dt">Codelet</span> <span class="dt">Twiddle</span> n</a>
<a class="sourceLine" id="cb7-48" title="48">      f <span class="ot">=</span> <span class="dt">Function</span> (codeletName codelet)<span class="ot"> ::</span> <span class="dt">TwiddleCodelet</span> a</a>
<a class="sourceLine" id="cb7-49" title="49">  plan <span class="ot">&lt;-</span> planTwiddle f inp twiddle</a>
<a class="sourceLine" id="cb7-50" title="50">  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Algorithm</span> (S.fromList [codelet]) <span class="fu">mempty</span> [<span class="dt">Expression</span> plan]</a>
<a class="sourceLine" id="cb7-51" title="51"></a>
<a class="sourceLine" id="cb7-52" title="52"><span class="ot">nFactorFFT ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="cb7-53" title="53">nFactorFFT [] _ _         <span class="ot">=</span> <span class="fu">return</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb7-54" title="54">nFactorFFT [x] inp out    <span class="ot">=</span> noTwiddleFFT x inp out</a>
<a class="sourceLine" id="cb7-55" title="55">nFactorFFT (x<span class="op">:</span>xs) inp out <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-56" title="56">  <span class="kw">let</span> n <span class="ot">=</span> <span class="fu">product</span> xs</a>
<a class="sourceLine" id="cb7-57" title="57">      w_array <span class="ot">=</span> <span class="dt">Array</span> (factorsName [n, x]) [n, x] (fromShape [n, x] <span class="dv">1</span>) <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-58" title="58">      subfft i <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-59" title="59">          inp&#39; <span class="ot">&lt;-</span> reshape [n, x] <span class="op">=&lt;&lt;</span> select <span class="dv">1</span> i inp</a>
<a class="sourceLine" id="cb7-60" title="60">          out&#39; <span class="ot">&lt;-</span> reshape [x, n] <span class="op">=&lt;&lt;</span> select <span class="dv">1</span> i out</a>
<a class="sourceLine" id="cb7-61" title="61">          (nFactorFFT xs (transpose inp&#39;) out&#39;)</a>
<a class="sourceLine" id="cb7-62" title="62">            <span class="op">&lt;&gt;</span> (twiddleFFT x (transpose out&#39;) w_array)</a>
<a class="sourceLine" id="cb7-63" title="63">            <span class="op">&lt;&gt;</span> <span class="dt">Right</span> (defineTwiddles [n, x])</a>
<a class="sourceLine" id="cb7-64" title="64"></a>
<a class="sourceLine" id="cb7-65" title="65">  l <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-66" title="66">  <span class="fu">mconcat</span> (<span class="fu">map</span> subfft [<span class="dv">0</span><span class="op">..</span>(l<span class="op">-</span><span class="dv">1</span>)])</a>
<a class="sourceLine" id="cb7-67" title="67"></a>
<a class="sourceLine" id="cb7-68" title="68"><span class="ot">factors ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb7-69" title="69">factors n <span class="ot">=</span> <span class="fu">sort</span> <span class="op">$</span> <span class="fu">concatMap</span> (\(i, m) <span class="ot">-&gt;</span> <span class="fu">take</span> m <span class="op">$</span> <span class="fu">repeat</span> (<span class="fu">fromIntegral</span><span class="ot"> i ::</span> <span class="dt">Int</span>)) (factorise <span class="op">$</span> <span class="fu">fromIntegral</span> n)</a>
<a class="sourceLine" id="cb7-70" title="70"></a>
<a class="sourceLine" id="cb7-71" title="71"><span class="ot">fullFactorFFT ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></a>
<a class="sourceLine" id="cb7-72" title="72">fullFactorFFT n <span class="ot">=</span> nFactorFFT (factors n)</a></code></pre></div>
<h2 id="appendix-miscellaneous-functions">Appendix: Miscellaneous functions</h2>
<p><em>file: «src/Lib.hs»=</em></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="op">&lt;&lt;</span>lib<span class="op">-</span>list<span class="op">-</span>manipulation<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="ot">tshow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-9" title="9">tshow <span class="ot">=</span> T.pack <span class="op">.</span> <span class="fu">show</span></a></code></pre></div>
<h3 id="list-manipulation">List manipulation</h3>
<p>We will be manipulating the shape and stride lists to slice the n-dimensional array. These operations just didn’t make it into Haskell’s standard library.</p>
<p><em>«lib-list-manipulation»=</em></p>
<div class="sourceCode" id="lib-list-manipulation"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="lib-list-manipulation-1" title="1"><span class="ot">remove ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="lib-list-manipulation-2" title="2">remove [] _ <span class="ot">=</span> []</a>
<a class="sourceLine" id="lib-list-manipulation-3" title="3">remove (x<span class="op">:</span>xs) n</a>
<a class="sourceLine" id="lib-list-manipulation-4" title="4">    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> xs</a>
<a class="sourceLine" id="lib-list-manipulation-5" title="5">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> remove xs (n <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="lib-list-manipulation-6" title="6"></a>
<a class="sourceLine" id="lib-list-manipulation-7" title="7"><span class="ot">replace ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="lib-list-manipulation-8" title="8">replace [] _  _ <span class="ot">=</span> []</a>
<a class="sourceLine" id="lib-list-manipulation-9" title="9">replace (x<span class="op">:</span>xs) n y</a>
<a class="sourceLine" id="lib-list-manipulation-10" title="10">    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> y<span class="op">:</span>xs</a>
<a class="sourceLine" id="lib-list-manipulation-11" title="11">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> replace xs (n <span class="op">-</span> <span class="dv">1</span>) y</a>
<a class="sourceLine" id="lib-list-manipulation-12" title="12"></a>
<a class="sourceLine" id="lib-list-manipulation-13" title="13"><span class="ot">insert ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="lib-list-manipulation-14" title="14">insert [] _  _ <span class="ot">=</span> []</a>
<a class="sourceLine" id="lib-list-manipulation-15" title="15">insert (x<span class="op">:</span>xs) n y</a>
<a class="sourceLine" id="lib-list-manipulation-16" title="16">    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> y<span class="op">:</span>x<span class="op">:</span>xs</a>
<a class="sourceLine" id="lib-list-manipulation-17" title="17">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> insert xs (n <span class="op">-</span> <span class="dv">1</span>) y</a></code></pre></div>
<h2 id="unit-tests-1">Unit tests</h2>
<p><em>file: «test/Spec.hs»=</em></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">import</span> <span class="dt">Data.Complex</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">import</span> <span class="dt">Control.Applicative</span> (liftA2)</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> (<span class="dt">Vector</span>)</a>
<a class="sourceLine" id="cb9-8" title="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb9-9" title="9"></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="kw">import</span> <span class="dt">Array</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">import</span> <span class="dt">TwiddleFactors</span></a>
<a class="sourceLine" id="cb9-13" title="13"></a>
<a class="sourceLine" id="cb9-14" title="14"><span class="op">&lt;&lt;</span>test<span class="op">-</span>predicates<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="ot">testTwiddleFactors ::</span> <span class="dt">Spec</span></a>
<a class="sourceLine" id="cb9-17" title="17">testTwiddleFactors <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-18" title="18">    <span class="op">&lt;&lt;</span>test<span class="op">-</span>twiddle<span class="op">-</span>factors<span class="op">&gt;&gt;</span></a>
<a class="sourceLine" id="cb9-19" title="19"></a>
<a class="sourceLine" id="cb9-20" title="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-21" title="21">main <span class="ot">=</span> hspec <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-22" title="22">    describe <span class="st">&quot;Strides.fromShape&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb9-23" title="23">        it <span class="st">&quot;computes strides from shapes&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-24" title="24">            fromShape [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>] <span class="dv">1</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>]</a>
<a class="sourceLine" id="cb9-25" title="25">            fromShape [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>] <span class="dv">1</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>]</a>
<a class="sourceLine" id="cb9-26" title="26"></a>
<a class="sourceLine" id="cb9-27" title="27">    describe <span class="st">&quot;Strides.remove&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb9-28" title="28">        it <span class="st">&quot;drops indexed entry from list&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-29" title="29">            remove [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="ot">`shouldBe`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-30" title="30">            remove [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-31" title="31"></a>
<a class="sourceLine" id="cb9-32" title="32">    describe <span class="st">&quot;Strides.replace&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb9-33" title="33">        it <span class="st">&quot;replaces entry at index&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-34" title="34">            replace [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-35" title="35">            replace [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-36" title="36"></a>
<a class="sourceLine" id="cb9-37" title="37">    describe <span class="st">&quot;Strides.insert&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb9-38" title="38">        it <span class="st">&quot;inserts entry at index&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-39" title="39">            insert [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-40" title="40">            insert [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-41" title="41"></a>
<a class="sourceLine" id="cb9-42" title="42">    <span class="kw">let</span> a1 <span class="ot">=</span> floatArray <span class="st">&quot;test&quot;</span> [<span class="dv">4</span>, <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb9-43" title="43">    describe <span class="st">&quot;Strides.select&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb9-44" title="44">        it <span class="st">&quot;selects sub-array&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-45" title="45">            <span class="kw">let</span> a103 <span class="ot">=</span> select a1 <span class="dv">0</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb9-46" title="46">            <span class="kw">let</span> a112 <span class="ot">=</span> select a1 <span class="dv">1</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb9-47" title="47">            (shape <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">5</span>]</a>
<a class="sourceLine" id="cb9-48" title="48">            (stride <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-49" title="49">            (offset <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb9-50" title="50">            (shape <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb9-51" title="51">            (stride <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb9-52" title="52">            (offset <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb9-53" title="53"></a>
<a class="sourceLine" id="cb9-54" title="54">    testTwiddleFactors</a></code></pre></div>
</body>
</html>
