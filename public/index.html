<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FFT Synthesis</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Dosis" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">FFT Synthesis</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#cooley-tukey-algorithm">Cooley-Tukey algorithm</a><ul>
<li><a href="#array-arithmetic">Array arithmetic</a></li>
<li><a href="#array-methods">Array methods</a></li>
</ul></li>
<li><a href="#codelets-and-twiddles">Codelets and Twiddles</a><ul>
<li><a href="#codelets">Codelets</a></li>
<li><a href="#calling-genfft">Calling GenFFT</a></li>
<li><a href="#twiddle-factors">Twiddle factors</a></li>
<li><a href="#unit-tests">Unit tests</a></li>
</ul></li>
<li><a href="#abstract-syntax-tree">Abstract Syntax Tree</a><ul>
<li><a href="#type-lists">Type lists</a></li>
<li><a href="#opencl-namespaces">OpenCL namespaces</a></li>
<li><a href="#basic-types">Basic types</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#generating-code">Generating code</a></li>
<li><a href="#ast-module">AST Module</a></li>
</ul></li>
<li><a href="#synthesis-of-fft">Synthesis of FFT</a><ul>
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#synthesis-module">Synthesis Module</a></li>
</ul></li>
<li><a href="#appendix-miscellaneous-functions">Appendix: Miscellaneous functions</a><ul>
<li><a href="#list-manipulation">List manipulation</a></li>
</ul></li>
<li><a href="#unit-tests-1">Unit tests</a></li>
<li><a href="#run-models">Run models</a><ul>
<li><a href="#channels">Channels</a></li>
<li><a href="#auto-kernel-generator">Auto-kernel generator</a></li>
</ul></li>
</ul>
</nav>
<h2 id="cooley-tukey-algorithm">Cooley-Tukey algorithm</h2>
<p>(sampled from Frigo 1999. I changed array indices to <span class="math inline">\(k, l, m\)</span>, <span class="math inline">\(n\)</span> denoting the length of the array.)</p>
<p>The (forward) discrete Fourier transform of <span class="math inline">\(X\)</span> is the array <span class="math inline">\(Y\)</span> given by</p>
<p><span id="eq:dft" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[l] = \sum_{k=0}^{n-1} X[k] w_n^{-kl},\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(1)</span></span> </p>
<p>where</p>
<p><span id="eq:wn" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[w_n = \exp\left(\frac{2\pi i}{n}\right).\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(2)</span></span> </p>
<p>So <span class="math inline">\(w_n^{-kl}\)</span> denotes <span class="math inline">\(w_n\)</span> <em>to the power of</em> <span class="math inline">\(-kl\)</span>.</p>
<p>In the case that <span class="math inline">\(X\)</span> is real valued, <span class="math inline">\(Y\)</span> will have <em>hermitian symmetry</em></p>
<p><span id="eq:hermitian-symmetry" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[n - k] = Y^*[k].\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(3)</span></span> </p>
<p>The backward DFT flips the sign at the exponent of <span class="math inline">\(w_n\)</span>, giving</p>
<p><span id="eq:idft" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[Y[l] = \sum_{k=0}^{n-1} X[k] w_n^{kl}.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(4)</span></span> </p>
<p>Now suppose that <span class="math inline">\(n\)</span> can be factored into <span class="math inline">\(n = n_1 n_2\)</span>. We may now view the arrays <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> in a rectangular shape, where</p>
<p><span class="math display">\[X[k] = X[k_1 n_2 + k_2] = X[k_1, k_2].\]</span></p>
<p>Also, let <span class="math inline">\(Y\)</span> take the transposed shape of <span class="math inline">\(X\)</span>,</p>
<p><span class="math display">\[Y[l] = Y[l_1 + l_2 n_1] = Y[l_1, l_2].\]</span></p>
<p>Then eq. <a href="#eq:dft">1</a> can be written as</p>
<p><span class="math display">\[Y[l_1, l_2] = \sum_{k_2 = 0}^{n_2 - 1} \left[\left(\sum_{k_1 = 0}^{n_1-1} X[k_1, k_2] w_{n_1}^{-k_1 l_1}\right) w_n^{l_1 k_2}\right] w_{n_2}^{-l_2 k_2}.\]</span></p>
<p>Also known as the <strong>Cooley-Tukey fast Fourier transform</strong>.</p>
<p>This separates the DFT in an inner and outer transform, of sizes <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span>. The output of the inner transform is multiplied by <strong>twiddle factors</strong> <span class="math inline">\(w_n^{-l_1 k_2}\)</span>, before the outer transform is done.</p>
<h3 id="array-arithmetic">Array arithmetic</h3>
<figure>
<img src="cooley-tukey-20.svg" id="fig:cooley-tukey-array" alt="" /><figcaption><span>Figure 1:</span> Cooley-Tukey algorithm for an <span class="math inline">\(n=20\)</span> array.</figcaption>
</figure>
<p>We will express different stages of the FFT by applying a vectorised FFT on a multi-dimensional strided numeric array. In the following example we compute an <span class="math inline">\(n=20\)</span> transform by doing four radix-5 transforms followed by five <span class="math inline">\(2 \times 2\)</span> transforms. The abstraction of using multi-dimensional arrays is a useful one to keep track of the offsets and strides involved, see fig. <a href="#fig:cooley-tukey-array">1</a>.</p>
<p>We define the <code>Array</code> module to handle array manipulation in abstraction, similar to array slicing in NumPy.</p>
<p><em>file: «src/Array.hs»=</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">module</span> <span class="dt">Array</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="dt">Data.Complex</span> (<span class="dt">Complex</span>(..))</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="op">&lt;&lt;</span>array<span class="op">-</span>numeric<span class="op">-</span><span class="kw">class</span><span class="op">&gt;&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="op">&lt;&lt;</span>array<span class="op">-</span>types<span class="op">&gt;&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="op">&lt;&lt;</span>array<span class="op">-</span>methods<span class="op">&gt;&gt;</span></span></code></pre></div>
<h4 id="numeric-types">Numeric types</h4>
<p>The <code>NumericType</code> type-class is defined so that we can constrain functions to work with <code>Float</code>, <code>Double</code> or <code>Complex a</code>. This also gives information on the byte size of each numeric type. We need to give <code>byteSize</code> an argument for it to be able to deduce the type, for which we use the <code>Proxy</code> type.</p>
<p><em>«array-numeric-class»=</em></p>
<div class="sourceCode" id="array-numeric-class"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-numeric-class-1"><a href="#array-numeric-class-1"></a><span class="kw">class</span> <span class="dt">NumericType</span> a <span class="kw">where</span></span>
<span id="array-numeric-class-2"><a href="#array-numeric-class-2"></a><span class="ot">    byteSize ::</span> proxy a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="array-numeric-class-3"><a href="#array-numeric-class-3"></a></span>
<span id="array-numeric-class-4"><a href="#array-numeric-class-4"></a><span class="kw">instance</span> <span class="dt">NumericType</span> <span class="dt">Float</span> <span class="kw">where</span></span>
<span id="array-numeric-class-5"><a href="#array-numeric-class-5"></a>    byteSize _ <span class="ot">=</span> <span class="dv">4</span></span>
<span id="array-numeric-class-6"><a href="#array-numeric-class-6"></a></span>
<span id="array-numeric-class-7"><a href="#array-numeric-class-7"></a><span class="kw">instance</span> <span class="dt">NumericType</span> <span class="dt">Double</span> <span class="kw">where</span></span>
<span id="array-numeric-class-8"><a href="#array-numeric-class-8"></a>    byteSize _ <span class="ot">=</span> <span class="dv">8</span></span>
<span id="array-numeric-class-9"><a href="#array-numeric-class-9"></a></span>
<span id="array-numeric-class-10"><a href="#array-numeric-class-10"></a><span class="kw">instance</span> (<span class="dt">NumericType</span> a) <span class="ot">=&gt;</span> <span class="dt">NumericType</span> (<span class="dt">Complex</span> a) <span class="kw">where</span></span>
<span id="array-numeric-class-11"><a href="#array-numeric-class-11"></a>    byteSize _ <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> (byteSize (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a))</span></code></pre></div>
<h4 id="array-structure">Array structure</h4>
<p>An array has a shape, stride and offset, in addition to a name meant to identify the array in question.</p>
<p><em>«array-types»=</em></p>
<div class="sourceCode" id="array-types"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-types-1"><a href="#array-types-1"></a><span class="kw">type</span> <span class="dt">Shape</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="array-types-2"><a href="#array-types-2"></a><span class="kw">type</span> <span class="dt">Stride</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="array-types-3"><a href="#array-types-3"></a></span>
<span id="array-types-4"><a href="#array-types-4"></a><span class="kw">data</span> <span class="dt">Array</span> a <span class="ot">=</span> <span class="dt">Array</span></span>
<span id="array-types-5"><a href="#array-types-5"></a>    {<span class="ot"> name     ::</span> <span class="dt">Text</span></span>
<span id="array-types-6"><a href="#array-types-6"></a>    ,<span class="ot"> shape    ::</span> <span class="dt">Shape</span></span>
<span id="array-types-7"><a href="#array-types-7"></a>    ,<span class="ot"> stride   ::</span> <span class="dt">Stride</span></span>
<span id="array-types-8"><a href="#array-types-8"></a>    ,<span class="ot"> offset   ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="array-types-9"><a href="#array-types-9"></a></span>
<span id="array-types-10"><a href="#array-types-10"></a><span class="co">-- data ArrayIndex a = ArrayIndex</span></span>
<span id="array-types-11"><a href="#array-types-11"></a><span class="co">--    { name     :: Text</span></span>
<span id="array-types-12"><a href="#array-types-12"></a><span class="co">--     , index    :: Int } deriving (Show)</span></span>
<span id="array-types-13"><a href="#array-types-13"></a></span>
<span id="array-types-14"><a href="#array-types-14"></a><span class="ot">floatArray ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Float</span></span>
<span id="array-types-15"><a href="#array-types-15"></a>floatArray name shape <span class="ot">=</span> <span class="dt">Array</span> name shape (fromShape shape <span class="dv">1</span>) <span class="dv">0</span></span></code></pre></div>
<p>The stride gives the distance in memory (counted in number of items, not bytes) for a step in each axis of the array. The location in memory can be computed using the dot-product,</p>
<p><span id="eq:strides" style="display: inline-block; position: relative; width: 100%"><span class="math display">\[{\rm location} = {\rm stride} \cdot {\rm index} + {\rm offset}.\]</span><span style="position: absolute; right: 0em; top: 50%; line-height:0; text-align: right">(5)</span></span> </p>
<h3 id="array-methods">Array methods</h3>
<p>Given a contiguous array of a given shape, we can compute the stride by taking the cumulative product.</p>
<p><em>«array-methods»=</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">fromShape ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stride</span></span>
<span id="array-methods-2"><a href="#array-methods-2"></a>fromShape [] _ <span class="ot">=</span> []</span>
<span id="array-methods-3"><a href="#array-methods-3"></a>fromShape (x<span class="op">:</span>xs) n <span class="ot">=</span> n <span class="op">:</span> fromShape xs (n <span class="op">*</span> x)</span></code></pre></div>
<h4 id="properties">Properties</h4>
<p>Basic properties of an array: size, dimension and if the array is contiguous.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">ndim ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="array-methods-2"><a href="#array-methods-2"></a>ndim <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> shape</span>
<span id="array-methods-3"><a href="#array-methods-3"></a></span>
<span id="array-methods-4"><a href="#array-methods-4"></a><span class="ot">contiguous ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="array-methods-5"><a href="#array-methods-5"></a>contiguous <span class="dt">Array</span>{shape,stride} <span class="ot">=</span> stride <span class="op">==</span> fromShape shape (<span class="fu">head</span> stride)</span></code></pre></div>
<h4 id="error-handling">Error handling</h4>
<p>Methods that can fail will return a type <code>Either Text a</code>. Since that type implements the <code>MonadError</code> class we can throw errors using <code>throwError</code> and at success <code>return</code> a value. We can generalize this pattern by accepting just any <code>MonadError Text</code> type.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">rcheck ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m ()</span>
<span id="array-methods-2"><a href="#array-methods-2"></a>rcheck what n i</span>
<span id="array-methods-3"><a href="#array-methods-3"></a>    <span class="op">|</span> (i <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="op">&amp;&amp;</span> (i <span class="op">&lt;</span> n) <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="array-methods-4"><a href="#array-methods-4"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> throwError <span class="op">$</span> <span class="st">&quot;Range check error: &quot;</span> <span class="op">&lt;&gt;</span> what <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span></span>
<span id="array-methods-5"><a href="#array-methods-5"></a>                <span class="op">&lt;&gt;</span> tshow n <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> tshow i</span></code></pre></div>
<p>The <code>rcheck</code> function implements a range-check on the range <code>0 .. (n-1)</code>.</p>
<h4 id="reshaping-slicing">Reshaping, slicing</h4>
<p>If we have an array of complex values, we want to read out the real and imaginary parts.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">realPart ::</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> a</span>
<span id="array-methods-2"><a href="#array-methods-2"></a>realPart array<span class="op">@</span><span class="dt">Array</span>{stride,offset} <span class="ot">=</span> array</span>
<span id="array-methods-3"><a href="#array-methods-3"></a>    { stride <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span> <span class="dv">2</span>) stride, offset <span class="ot">=</span> offset<span class="op">*</span><span class="dv">2</span> }</span>
<span id="array-methods-4"><a href="#array-methods-4"></a></span>
<span id="array-methods-5"><a href="#array-methods-5"></a><span class="ot">imagPart ::</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> a</span>
<span id="array-methods-6"><a href="#array-methods-6"></a>imagPart array<span class="op">@</span><span class="dt">Array</span>{stride, offset} <span class="ot">=</span> array</span>
<span id="array-methods-7"><a href="#array-methods-7"></a>    { stride <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span> <span class="dv">2</span>) stride</span>
<span id="array-methods-8"><a href="#array-methods-8"></a>    , offset <span class="ot">=</span> offset<span class="op">*</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span> }</span></code></pre></div>
<p>Transposing an array means reversing the shape and stride vectors</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">transpose ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> a</span>
<span id="array-methods-2"><a href="#array-methods-2"></a>transpose array<span class="op">@</span><span class="dt">Array</span>{shape, stride} <span class="ot">=</span> array</span>
<span id="array-methods-3"><a href="#array-methods-3"></a>    { shape <span class="ot">=</span> <span class="fu">reverse</span> shape</span>
<span id="array-methods-4"><a href="#array-methods-4"></a>    , stride <span class="ot">=</span> <span class="fu">reverse</span> stride }</span></code></pre></div>
<p>Reshaping is only possible from an array that can be flattened to a one-dimensional array with constant stride. Otherwise the arithmetic of stepping through the resulting array would no longer be expressible in terms of a stride and offset.</p>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">reshape ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</span>
<span id="array-methods-2"><a href="#array-methods-2"></a>reshape newShape array</span>
<span id="array-methods-3"><a href="#array-methods-3"></a>    <span class="op">|</span> (ndim array) <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> array</span>
<span id="array-methods-4"><a href="#array-methods-4"></a>        { shape <span class="ot">=</span> newShape</span>
<span id="array-methods-5"><a href="#array-methods-5"></a>        , stride <span class="ot">=</span> fromShape newShape (<span class="fu">head</span> <span class="op">$</span> stride array) }</span>
<span id="array-methods-6"><a href="#array-methods-6"></a>    <span class="op">|</span> contiguous array <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> array</span>
<span id="array-methods-7"><a href="#array-methods-7"></a>        { shape <span class="ot">=</span> newShape</span>
<span id="array-methods-8"><a href="#array-methods-8"></a>        , stride <span class="ot">=</span> fromShape newShape <span class="dv">1</span> }</span>
<span id="array-methods-9"><a href="#array-methods-9"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> throwError <span class="st">&quot;Cannot reshape multi-dimensional non-contiguous array.&quot;</span></span></code></pre></div>
<p>The <code>select</code>, <code>extrude</code>, and <code>slice</code> methods do the same as the Numpy array slice notation.</p>
<table>
<thead>
<tr class="header">
<th>Numpy</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a[:,3]</code></td>
<td><code>select a 1 3</code></td>
<td>Select 4th column</td>
</tr>
<tr class="even">
<td><code>a[3:9:2,:]</code></td>
<td><code>slice a 0 3 9 2</code></td>
<td>Slice rows 4, 6 and 8</td>
</tr>
<tr class="odd">
<td><code>a[:,None,:]</code></td>
<td><code>extrude a 1</code></td>
<td>Extrude a new axis</td>
</tr>
</tbody>
</table>
<p><em>«array-methods»=+</em></p>
<div class="sourceCode" id="array-methods"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="array-methods-1"><a href="#array-methods-1"></a><span class="ot">select ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</span>
<span id="array-methods-2"><a href="#array-methods-2"></a>select dim i array<span class="op">@</span><span class="dt">Array</span>{shape,stride,offset} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="array-methods-3"><a href="#array-methods-3"></a>    rcheck <span class="st">&quot;dim&quot;</span> (ndim array) dim</span>
<span id="array-methods-4"><a href="#array-methods-4"></a>    rcheck <span class="st">&quot;size&quot;</span> (shape <span class="op">!!</span> dim) i</span>
<span id="array-methods-5"><a href="#array-methods-5"></a>    <span class="fu">return</span> <span class="op">$</span> array</span>
<span id="array-methods-6"><a href="#array-methods-6"></a>        { shape  <span class="ot">=</span> remove shape dim</span>
<span id="array-methods-7"><a href="#array-methods-7"></a>        , stride <span class="ot">=</span> remove stride dim</span>
<span id="array-methods-8"><a href="#array-methods-8"></a>        , offset <span class="ot">=</span> offset <span class="op">+</span> (stride <span class="op">!!</span> dim) <span class="op">*</span> i }</span>
<span id="array-methods-9"><a href="#array-methods-9"></a></span>
<span id="array-methods-10"><a href="#array-methods-10"></a><span class="ot">extrude ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</span>
<span id="array-methods-11"><a href="#array-methods-11"></a>extrude dim array<span class="op">@</span><span class="dt">Array</span>{shape,stride} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="array-methods-12"><a href="#array-methods-12"></a>    rcheck <span class="st">&quot;dim&quot;</span> (ndim array <span class="op">+</span> <span class="dv">1</span>) dim</span>
<span id="array-methods-13"><a href="#array-methods-13"></a>    <span class="fu">return</span> <span class="op">$</span> array</span>
<span id="array-methods-14"><a href="#array-methods-14"></a>        { shape  <span class="ot">=</span> insert shape dim <span class="dv">1</span></span>
<span id="array-methods-15"><a href="#array-methods-15"></a>        , stride <span class="ot">=</span> insert stride dim ((stride <span class="op">!!</span> dim) <span class="op">*</span> (shape <span class="op">!!</span> dim)) }</span>
<span id="array-methods-16"><a href="#array-methods-16"></a></span>
<span id="array-methods-17"><a href="#array-methods-17"></a><span class="ot">slice ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> m (<span class="dt">Array</span> a)</span>
<span id="array-methods-18"><a href="#array-methods-18"></a>slice dim a b step array<span class="op">@</span><span class="dt">Array</span>{shape,stride,offset} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="array-methods-19"><a href="#array-methods-19"></a>    rcheck <span class="st">&quot;dim&quot;</span> (ndim array) dim</span>
<span id="array-methods-20"><a href="#array-methods-20"></a>    rcheck <span class="st">&quot;a&quot;</span> ((shape <span class="op">!!</span> dim) <span class="op">+</span> <span class="dv">1</span>) a</span>
<span id="array-methods-21"><a href="#array-methods-21"></a>    rcheck <span class="st">&quot;b&quot;</span> ((shape <span class="op">!!</span> dim) <span class="op">+</span> <span class="dv">1</span>) b</span>
<span id="array-methods-22"><a href="#array-methods-22"></a>    <span class="fu">return</span> <span class="op">$</span> array</span>
<span id="array-methods-23"><a href="#array-methods-23"></a>        { shape  <span class="ot">=</span> replace shape  dim ((b <span class="op">-</span> a) <span class="ot">`quot`</span> step)</span>
<span id="array-methods-24"><a href="#array-methods-24"></a>        , stride <span class="ot">=</span> replace stride dim ((stride <span class="op">!!</span> dim) <span class="op">*</span> step)</span>
<span id="array-methods-25"><a href="#array-methods-25"></a>        , offset <span class="ot">=</span> offset <span class="op">+</span> (stride <span class="op">!!</span> dim) <span class="op">*</span> a }</span></code></pre></div>
<h2 id="codelets-and-twiddles">Codelets and Twiddles</h2>
<h3 id="codelets">Codelets</h3>
<p>A codelet, for the moment, is just some function that we can call.</p>
<p><em>file: «src/Codelet.hs»=</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">{-# LANGUAGE DataKinds,GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">module</span> <span class="dt">Codelet</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  ( <span class="dt">Codelet</span>(<span class="op">..</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a>  , <span class="dt">CodeletType</span>(<span class="op">..</span>)</span>
<span id="cb2-7"><a href="#cb2-7"></a>  , codeletName</span>
<span id="cb2-8"><a href="#cb2-8"></a>  , codeletPrefix</span>
<span id="cb2-9"><a href="#cb2-9"></a>  , <span class="dt">NoTwiddleCodelet</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  , <span class="dt">TwiddleCodelet</span> ) <span class="kw">where</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">AST</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Array</span></span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="kw">data</span> <span class="dt">CodeletType</span> <span class="ot">=</span> <span class="dt">Twiddle</span> <span class="op">|</span> <span class="dt">NoTwiddle</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb2-19"><a href="#cb2-19"></a></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="kw">data</span> <span class="dt">Codelet</span> <span class="ot">=</span> <span class="dt">Codelet</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>  {<span class="ot"> codeletType  ::</span> <span class="dt">CodeletType</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>  ,<span class="ot"> codeletRadix ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-23"><a href="#cb2-23"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</span>
<span id="cb2-24"><a href="#cb2-24"></a></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="ot">codeletPrefix ::</span> <span class="dt">Codelet</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>codeletPrefix <span class="dt">Codelet</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="kw">case</span> codeletType <span class="kw">of</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="dt">Twiddle</span> <span class="ot">-&gt;</span> <span class="st">&quot;twiddle&quot;</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="dt">NoTwiddle</span> <span class="ot">-&gt;</span> <span class="st">&quot;notw&quot;</span></span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="ot">codeletName ::</span> <span class="dt">Codelet</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>codeletName x<span class="op">@</span><span class="dt">Codelet</span>{<span class="op">..</span>} <span class="ot">=</span> codeletPrefix x <span class="op">&lt;&gt;</span> <span class="st">&quot;_&quot;</span> <span class="op">&lt;&gt;</span> tshow codeletRadix</span>
<span id="cb2-32"><a href="#cb2-32"></a></span>
<span id="cb2-33"><a href="#cb2-33"></a><span class="kw">type</span> <span class="dt">NoTwiddleCodelet</span> a <span class="ot">=</span> <span class="dt">Function</span></span>
<span id="cb2-34"><a href="#cb2-34"></a>  [ <span class="dt">Array</span> a, <span class="dt">Array</span> a</span>
<span id="cb2-35"><a href="#cb2-35"></a>  , <span class="dt">Array</span> a, <span class="dt">Array</span> a</span>
<span id="cb2-36"><a href="#cb2-36"></a>  , <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span> ] ()</span>
<span id="cb2-37"><a href="#cb2-37"></a></span>
<span id="cb2-38"><a href="#cb2-38"></a><span class="kw">type</span> <span class="dt">TwiddleCodelet</span> a <span class="ot">=</span> <span class="dt">Function</span></span>
<span id="cb2-39"><a href="#cb2-39"></a>  [ <span class="dt">Array</span> a, <span class="dt">Array</span> a</span>
<span id="cb2-40"><a href="#cb2-40"></a>  , <span class="dt">Array</span> a</span>
<span id="cb2-41"><a href="#cb2-41"></a>  , <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span> ] ()</span></code></pre></div>
<h3 id="calling-genfft">Calling GenFFT</h3>
<p>This is an interface to the GenFFT executables. The most generic function here is <code>gen</code>, which can be passed a <code>Codelet</code> and a <code>GenFFTArgs</code> value, returning the generated code as <code>IO Text</code>.</p>
<p><em>file: «src/GenFFT.hs»=</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">module</span> <span class="dt">GenFFT</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">import</span> <span class="dt">System.Process</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">import</span> <span class="dt">Codelet</span> (<span class="dt">Codelet</span>(..), codeletName, codeletPrefix)</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">import</span> <span class="dt">Lib</span> (tshow)</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="kw">class</span> <span class="dt">ValidArg</span> a <span class="kw">where</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="ot">  toText ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  toText <span class="ot">=</span> T.pack</span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Text</span> <span class="kw">where</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>  toText <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>  toText <span class="ot">=</span> tshow</span>
<span id="cb3-24"><a href="#cb3-24"></a></span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="kw">instance</span> <span class="dt">ValidArg</span> <span class="dt">Double</span> <span class="kw">where</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>  toText <span class="ot">=</span> tshow</span>
<span id="cb3-27"><a href="#cb3-27"></a></span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="ot">macros ::</span> [(<span class="dt">Text</span>, <span class="dt">Text</span>)]</span>
<span id="cb3-29"><a href="#cb3-29"></a>macros <span class="ot">=</span></span>
<span id="cb3-30"><a href="#cb3-30"></a>  [ (<span class="st">&quot;R&quot;</span>,<span class="st">&quot;float&quot;</span>)</span>
<span id="cb3-31"><a href="#cb3-31"></a>  , (<span class="st">&quot;E&quot;</span>,<span class="st">&quot;R&quot;</span>)</span>
<span id="cb3-32"><a href="#cb3-32"></a>  , (<span class="st">&quot;stride&quot;</span>,<span class="st">&quot;int&quot;</span>)</span>
<span id="cb3-33"><a href="#cb3-33"></a>  , (<span class="st">&quot;INT&quot;</span>,<span class="st">&quot;int&quot;</span>)</span>
<span id="cb3-34"><a href="#cb3-34"></a>  , (<span class="st">&quot;K(x)&quot;</span>,<span class="st">&quot;((E) x)&quot;</span>)</span>
<span id="cb3-35"><a href="#cb3-35"></a>  , (<span class="st">&quot;DK(name,value)&quot;</span>,<span class="st">&quot;const E name = K(value)&quot;</span>)</span>
<span id="cb3-36"><a href="#cb3-36"></a>  , (<span class="st">&quot;WS(s,i)&quot;</span>,<span class="st">&quot;s*i&quot;</span>)</span>
<span id="cb3-37"><a href="#cb3-37"></a>  , (<span class="st">&quot;MAKE_VOLATILE_STRIDE(x,y)&quot;</span>,<span class="st">&quot;0&quot;</span>)</span>
<span id="cb3-38"><a href="#cb3-38"></a>  , (<span class="st">&quot;FMA(a,b,c)&quot;</span>,<span class="st">&quot;a * b + c&quot;</span>)</span>
<span id="cb3-39"><a href="#cb3-39"></a>  , (<span class="st">&quot;FMS(a,b,c)&quot;</span>,<span class="st">&quot;a * b - c&quot;</span>)</span>
<span id="cb3-40"><a href="#cb3-40"></a>  , (<span class="st">&quot;FNMA(a,b,c)&quot;</span>,<span class="st">&quot;-a * b - c&quot;</span>)</span>
<span id="cb3-41"><a href="#cb3-41"></a>  , (<span class="st">&quot;FNMS(a,b,c)&quot;</span>,<span class="st">&quot;-a * b + c&quot;</span>) ]</span>
<span id="cb3-42"><a href="#cb3-42"></a></span>
<span id="cb3-43"><a href="#cb3-43"></a><span class="ot">genMacros ::</span> <span class="dt">Text</span></span>
<span id="cb3-44"><a href="#cb3-44"></a>genMacros <span class="ot">=</span> T.unlines <span class="op">$</span> <span class="fu">map</span> (\(k, v) <span class="ot">-&gt;</span> <span class="st">&quot;#define &quot;</span> <span class="op">&lt;&gt;</span> k <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> v) macros</span>
<span id="cb3-45"><a href="#cb3-45"></a></span>
<span id="cb3-46"><a href="#cb3-46"></a><span class="ot">genFFT ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb3-47"><a href="#cb3-47"></a>genFFT kind args <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-48"><a href="#cb3-48"></a>  <span class="kw">let</span> progName <span class="ot">=</span> T.unpack <span class="op">$</span> <span class="st">&quot;./genfft/gen_&quot;</span> <span class="op">&lt;&gt;</span> kind <span class="op">&lt;&gt;</span> <span class="st">&quot;.native&quot;</span></span>
<span id="cb3-49"><a href="#cb3-49"></a>      <span class="co">-- spec = RawCommand progName (map T.unpack args)</span></span>
<span id="cb3-50"><a href="#cb3-50"></a>  code <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> readProcess progName (<span class="fu">map</span> T.unpack args) <span class="st">&quot;&quot;</span></span>
<span id="cb3-51"><a href="#cb3-51"></a>  indent code</span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a><span class="ot">indent ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb3-54"><a href="#cb3-54"></a>indent x <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> readProcess <span class="st">&quot;indent&quot;</span> [<span class="st">&quot;-nut&quot;</span>] (T.unpack x)</span>
<span id="cb3-55"><a href="#cb3-55"></a></span>
<span id="cb3-56"><a href="#cb3-56"></a><span class="kw">data</span> <span class="dt">GenFFTArgs</span> <span class="ot">=</span> <span class="dt">GenFFTArgs</span></span>
<span id="cb3-57"><a href="#cb3-57"></a>  {<span class="ot"> compact     ::</span> <span class="dt">Bool</span></span>
<span id="cb3-58"><a href="#cb3-58"></a>  ,<span class="ot"> standalone  ::</span> <span class="dt">Bool</span></span>
<span id="cb3-59"><a href="#cb3-59"></a>  ,<span class="ot"> opencl      ::</span> <span class="dt">Bool</span></span>
<span id="cb3-60"><a href="#cb3-60"></a>  ,<span class="ot"> name        ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb3-61"><a href="#cb3-61"></a></span>
<span id="cb3-62"><a href="#cb3-62"></a><span class="ot">defaultArgs ::</span> <span class="dt">GenFFTArgs</span></span>
<span id="cb3-63"><a href="#cb3-63"></a>defaultArgs <span class="ot">=</span> <span class="dt">GenFFTArgs</span></span>
<span id="cb3-64"><a href="#cb3-64"></a>  { compact <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-65"><a href="#cb3-65"></a>  , standalone <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb3-66"><a href="#cb3-66"></a>  , opencl <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb3-67"><a href="#cb3-67"></a>  , name <span class="ot">=</span> <span class="dt">Nothing</span> }</span>
<span id="cb3-68"><a href="#cb3-68"></a></span>
<span id="cb3-69"><a href="#cb3-69"></a><span class="ot">optionalArg ::</span> (<span class="dt">ValidArg</span> a) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</span>
<span id="cb3-70"><a href="#cb3-70"></a>optionalArg opt <span class="ot">=</span> <span class="fu">maybe</span> [] (\n <span class="ot">-&gt;</span> [opt, toText n])</span>
<span id="cb3-71"><a href="#cb3-71"></a></span>
<span id="cb3-72"><a href="#cb3-72"></a><span class="ot">argList ::</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> [<span class="dt">Text</span>]</span>
<span id="cb3-73"><a href="#cb3-73"></a>argList <span class="dt">GenFFTArgs</span>{<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb3-74"><a href="#cb3-74"></a>  optionalArg <span class="st">&quot;-name&quot;</span> name</span>
<span id="cb3-75"><a href="#cb3-75"></a>  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-compact&quot;</span> <span class="op">|</span> compact]</span>
<span id="cb3-76"><a href="#cb3-76"></a>  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-standalone&quot;</span> <span class="op">|</span> standalone]</span>
<span id="cb3-77"><a href="#cb3-77"></a>  <span class="op">&lt;&gt;</span> [<span class="st">&quot;-opencl&quot;</span> <span class="op">|</span> opencl]</span>
<span id="cb3-78"><a href="#cb3-78"></a></span>
<span id="cb3-79"><a href="#cb3-79"></a><span class="ot">genNoTwiddle ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb3-80"><a href="#cb3-80"></a>genNoTwiddle radix args <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-81"><a href="#cb3-81"></a>  <span class="kw">let</span> name&#39; <span class="ot">=</span> fromMaybe (<span class="st">&quot;notw_&quot;</span> <span class="op">&lt;&gt;</span> tshow radix) (name args)</span>
<span id="cb3-82"><a href="#cb3-82"></a>  genFFT <span class="st">&quot;notw&quot;</span> <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow radix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</span>
<span id="cb3-83"><a href="#cb3-83"></a></span>
<span id="cb3-84"><a href="#cb3-84"></a><span class="ot">genTwiddle ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb3-85"><a href="#cb3-85"></a>genTwiddle radix args <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-86"><a href="#cb3-86"></a>  <span class="kw">let</span> name&#39; <span class="ot">=</span> fromMaybe (<span class="st">&quot;twiddle_&quot;</span> <span class="op">&lt;&gt;</span> tshow radix) (name args)</span>
<span id="cb3-87"><a href="#cb3-87"></a>  genFFT <span class="st">&quot;twiddle&quot;</span> <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow radix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</span>
<span id="cb3-88"><a href="#cb3-88"></a></span>
<span id="cb3-89"><a href="#cb3-89"></a><span class="ot">gen ::</span> <span class="dt">GenFFTArgs</span> <span class="ot">-&gt;</span> <span class="dt">Codelet</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Text</span></span>
<span id="cb3-90"><a href="#cb3-90"></a>gen args codelet<span class="op">@</span><span class="dt">Codelet</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-91"><a href="#cb3-91"></a>  <span class="kw">let</span> name&#39; <span class="ot">=</span> codeletName codelet</span>
<span id="cb3-92"><a href="#cb3-92"></a>  genFFT (codeletPrefix codelet) <span class="op">$</span> [<span class="st">&quot;-n&quot;</span>, tshow codeletRadix] <span class="op">&lt;&gt;</span> argList args{name<span class="ot">=</span><span class="dt">Just</span> name&#39;}</span></code></pre></div>
<h3 id="twiddle-factors">Twiddle factors</h3>
<p>In Python we created an array of twiddle factors:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">def</span> w(k, n):</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="cf">return</span> np.exp(2j <span class="op">*</span> np.pi <span class="op">*</span> k <span class="op">/</span> n)</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">def</span> make_twiddle(n1, n2):</span>
<span id="cb4-5"><a href="#cb4-5"></a>    I1 <span class="op">=</span> np.arange(n1)</span>
<span id="cb4-6"><a href="#cb4-6"></a>    I2 <span class="op">=</span> np.arange(n2)</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="cf">return</span> w(I1[:,<span class="va">None</span>] <span class="op">*</span> I2[<span class="va">None</span>,:], n1<span class="op">*</span>n2).astype(<span class="st">&#39;complex64&#39;</span>)</span></code></pre></div>
<p>In Haskell this is a bit different:</p>
<p><em>file: «src/TwiddleFactors.hs»=</em></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">module</span> <span class="dt">TwiddleFactors</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> (<span class="dt">Vector</span>)</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">import</span> <span class="dt">Array</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>w<span class="op">&gt;&gt;</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>multi<span class="op">-</span>w<span class="op">&gt;&gt;</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="op">&lt;&lt;</span>twiddle<span class="op">-</span>factors<span class="op">-</span>make<span class="op">&gt;&gt;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="ot">factorsName ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>factorsName s <span class="ot">=</span> <span class="st">&quot;w_&quot;</span> <span class="op">&lt;&gt;</span> T.intercalate <span class="st">&quot;_&quot;</span> (<span class="fu">map</span> tshow s)</span></code></pre></div>
<p>We still have the equation</p>
<p><span class="math display">\[w_n^k = \exp \left[2 \pi i \frac{k}{n}\right].\]</span></p>
<p>Haskell provides the function <code>cis</code> which computes a complex point on the unit circle given the phase.</p>
<p><em>«twiddle-factors-w»=</em></p>
<div class="sourceCode" id="twiddle-factors-w"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="twiddle-factors-w-1"><a href="#twiddle-factors-w-1"></a><span class="ot">w ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</span>
<span id="twiddle-factors-w-2"><a href="#twiddle-factors-w-2"></a>w n k <span class="ot">=</span> cis (<span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> <span class="fu">fromIntegral</span> k <span class="op">/</span> <span class="fu">fromIntegral</span> n)</span></code></pre></div>
<p>We need to map the index vector to a value <span class="math inline">\(w_{\prod n_i}^{\prod k_i}\)</span>.</p>
<p><em>«twiddle-factors-multi-w»=</em></p>
<div class="sourceCode" id="twiddle-factors-multi-w"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="twiddle-factors-multi-w-1"><a href="#twiddle-factors-multi-w-1"></a><span class="ot">multiW ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</span>
<span id="twiddle-factors-multi-w-2"><a href="#twiddle-factors-multi-w-2"></a>multiW n k <span class="ot">=</span> w (<span class="fu">product</span> n) (<span class="fu">product</span> k)</span></code></pre></div>
<p>To generate the list of indices (lists are lazy, so this should be efficient enough), we have a nifty one-liner. Given a list of indices for a reduced shape vector we can create the full list by prepending numbers from the range <code>[0 .. n-1]</code>.</p>
<p><em>«twiddle-factors-make»=</em></p>
<div class="sourceCode" id="twiddle-factors-make"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="twiddle-factors-make-1"><a href="#twiddle-factors-make-1"></a><span class="ot">indices ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="twiddle-factors-make-2"><a href="#twiddle-factors-make-2"></a>indices <span class="ot">=</span> <span class="fu">foldr</span> (\ n <span class="ot">-&gt;</span> <span class="fu">concatMap</span> (\ idcs <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">:</span> idcs) [<span class="dv">0</span> <span class="op">..</span> n<span class="op">-</span><span class="dv">1</span>])) [[]]</span>
<span id="twiddle-factors-make-3"><a href="#twiddle-factors-make-3"></a></span>
<span id="twiddle-factors-make-4"><a href="#twiddle-factors-make-4"></a><span class="ot">makeTwiddle ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">Complex</span> <span class="dt">Double</span>)</span>
<span id="twiddle-factors-make-5"><a href="#twiddle-factors-make-5"></a>makeTwiddle shape <span class="ot">=</span> V.fromList <span class="op">.</span> <span class="fu">map</span> (multiW shape) <span class="op">.</span> <span class="fu">drop</span> (<span class="fu">head</span> shape) <span class="op">$</span> indices shape</span></code></pre></div>
<h3 id="unit-tests">Unit tests</h3>
<p><em>«test-predicates»=</em></p>
<div class="sourceCode" id="test-predicates"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="test-predicates-1"><a href="#test-predicates-1"></a><span class="kw">class</span> <span class="dt">Approx</span> a <span class="kw">where</span></span>
<span id="test-predicates-2"><a href="#test-predicates-2"></a><span class="ot">    closeTo ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="test-predicates-3"><a href="#test-predicates-3"></a></span>
<span id="test-predicates-4"><a href="#test-predicates-4"></a><span class="kw">instance</span> <span class="dt">Approx</span> <span class="dt">Float</span> <span class="kw">where</span></span>
<span id="test-predicates-5"><a href="#test-predicates-5"></a>    closeTo a b <span class="ot">=</span> <span class="fu">abs</span> (a <span class="op">-</span> b) <span class="op">&lt;</span> <span class="fl">1e-5</span></span>
<span id="test-predicates-6"><a href="#test-predicates-6"></a></span>
<span id="test-predicates-7"><a href="#test-predicates-7"></a><span class="kw">instance</span> <span class="dt">Approx</span> <span class="dt">Double</span> <span class="kw">where</span></span>
<span id="test-predicates-8"><a href="#test-predicates-8"></a>    closeTo a b <span class="ot">=</span> <span class="fu">abs</span> (a <span class="op">-</span> b) <span class="op">&lt;</span> <span class="fl">1e-10</span></span>
<span id="test-predicates-9"><a href="#test-predicates-9"></a></span>
<span id="test-predicates-10"><a href="#test-predicates-10"></a><span class="kw">instance</span> (<span class="dt">Approx</span> a, <span class="dt">Applicative</span> m, <span class="dt">Foldable</span> m) <span class="ot">=&gt;</span> <span class="dt">Approx</span> (m a) <span class="kw">where</span></span>
<span id="test-predicates-11"><a href="#test-predicates-11"></a>    closeTo x y <span class="ot">=</span> <span class="fu">and</span> <span class="op">$</span> liftA2 closeTo x y</span>
<span id="test-predicates-12"><a href="#test-predicates-12"></a></span>
<span id="test-predicates-13"><a href="#test-predicates-13"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> (<span class="dt">Approx</span> a, <span class="dt">V.Unbox</span> a) <span class="ot">=&gt;</span> <span class="dt">Approx</span> (<span class="dt">Vector</span> a) <span class="kw">where</span></span>
<span id="test-predicates-14"><a href="#test-predicates-14"></a>    closeTo x y <span class="ot">=</span> V.and <span class="op">$</span> V.zipWith closeTo x y</span></code></pre></div>
<p><em>«test-twiddle-factors»=</em></p>
<div class="sourceCode" id="test-twiddle-factors"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="test-twiddle-factors-1"><a href="#test-twiddle-factors-1"></a>describe <span class="st">&quot;TwiddleFactors.indices&quot;</span> <span class="op">$</span></span>
<span id="test-twiddle-factors-2"><a href="#test-twiddle-factors-2"></a>    it <span class="st">&quot;creates an index list&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="test-twiddle-factors-3"><a href="#test-twiddle-factors-3"></a>        indices [<span class="dv">2</span>, <span class="dv">2</span>] <span class="ot">`shouldBe`</span> [[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">1</span>]]</span>
<span id="test-twiddle-factors-4"><a href="#test-twiddle-factors-4"></a>        indices [<span class="dv">3</span>, <span class="dv">1</span>] <span class="ot">`shouldBe`</span> [[<span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">2</span>, <span class="dv">0</span>]]</span>
<span id="test-twiddle-factors-5"><a href="#test-twiddle-factors-5"></a></span>
<span id="test-twiddle-factors-6"><a href="#test-twiddle-factors-6"></a>describe <span class="st">&quot;TwiddleFactors.makeTwiddle&quot;</span> <span class="op">$</span></span>
<span id="test-twiddle-factors-7"><a href="#test-twiddle-factors-7"></a>    it <span class="st">&quot;Generates twiddle factors&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="test-twiddle-factors-8"><a href="#test-twiddle-factors-8"></a>        makeTwiddle [<span class="dv">2</span>, <span class="dv">2</span>] <span class="ot">`shouldSatisfy`</span> closeTo</span>
<span id="test-twiddle-factors-9"><a href="#test-twiddle-factors-9"></a>            (V.fromList [ <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> <span class="fl">1.0</span> ])</span>
<span id="test-twiddle-factors-10"><a href="#test-twiddle-factors-10"></a>        makeTwiddle [<span class="dv">4</span>] <span class="ot">`shouldSatisfy`</span> closeTo</span>
<span id="test-twiddle-factors-11"><a href="#test-twiddle-factors-11"></a>            (V.fromList [ <span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> <span class="fl">1.0</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.0</span> <span class="op">:+</span> (<span class="op">-</span><span class="fl">1.0</span>) ])</span></code></pre></div>
<h2 id="abstract-syntax-tree">Abstract Syntax Tree</h2>
<p>To synthesise a larger FFT we have to duplicate some of the work done in GenFFT. We’ll describe calling the codelets and the matching loop structure in terms of an <em>abstract syntax tree</em>. The AST will contain a subset of OpenCL focussed on computing FFTs.</p>
<p>Describing code structure is somewhat of a specialty of Haskell. Modern Haskell has features to describe syntax trees that are completely type safe, meaning that any expression where the types to not match up (for instance between function parameters, and applied arguments) is ill-formed to the point that they’re impossible to construct. We need a few language extensions to make this work:</p>
<p><em>«ast-haskell-extensions»=</em></p>
<div class="sourceCode" id="ast-haskell-extensions"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-haskell-extensions-1"><a href="#ast-haskell-extensions-1"></a><span class="ot">{-# LANGUAGE GADTs,DataKinds,TypeOperators,KindSignatures #-}</span></span>
<span id="ast-haskell-extensions-2"><a href="#ast-haskell-extensions-2"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="ast-haskell-extensions-3"><a href="#ast-haskell-extensions-3"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="ast-haskell-extensions-4"><a href="#ast-haskell-extensions-4"></a><span class="ot">{-# LANGUAGE FlexibleInstances,UndecidableInstances #-}</span></span></code></pre></div>
<h3 id="type-lists">Type lists</h3>
<p>We need a way to declare the list of argument types to the codelets. In standard haskell this can be done by defining a recursive data-type, but the syntax would be ugly with lots of nested type expressions. The <code>DataKinds</code> and <code>TypeOperators</code> extensions let us define a type-level list structure and express it using normal list syntax (sometimes prefixed with a quote to disambiguate with data-level lists).</p>
<p><em>«ast-typelists»=</em></p>
<div class="sourceCode" id="ast-typelists"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-typelists-1"><a href="#ast-typelists-1"></a><span class="kw">data</span> <span class="dt">ArgList</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="ast-typelists-2"><a href="#ast-typelists-2"></a>    <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">ArgList</span> &#39;[]</span>
<span id="ast-typelists-3"><a href="#ast-typelists-3"></a><span class="ot">    (:+:) ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">ArgList</span> l <span class="ot">-&gt;</span> <span class="dt">ArgList</span> (a &#39;<span class="op">:</span> l)</span>
<span id="ast-typelists-4"><a href="#ast-typelists-4"></a></span>
<span id="ast-typelists-5"><a href="#ast-typelists-5"></a><span class="co">--deriving instance Show (ArgList &#39;[])</span></span>
<span id="ast-typelists-6"><a href="#ast-typelists-6"></a><span class="co">--deriving instance (Show (Expr a), Show (ArgList l)) =&gt; Show (ArgList (a &#39;: l))</span></span></code></pre></div>
<h3 id="opencl-namespaces">OpenCL namespaces</h3>
<p>OpenCL has several namespaces for different kinds of memory: <code>__constant</code>, <code>__global</code> and <code>__static</code> (there may be more, I don’t know).</p>
<p><em>«ast-ocl-namespaces»=</em></p>
<div class="sourceCode" id="ast-ocl-namespaces"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-ocl-namespaces-1"><a href="#ast-ocl-namespaces-1"></a><span class="kw">data</span> <span class="dt">NameSpace</span> <span class="ot">=</span> <span class="dt">Static</span> <span class="op">|</span> <span class="dt">Global</span> <span class="op">|</span> <span class="dt">Constant</span></span></code></pre></div>
<h3 id="basic-types">Basic types</h3>
<p>Many of the types that we define here exist just as type-level tags to larger expressions</p>
<p><em>«ast-basic-types»=</em></p>
<div class="sourceCode" id="ast-basic-types"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-basic-types-1"><a href="#ast-basic-types-1"></a><span class="kw">class</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Declarable</span> a <span class="kw">where</span></span>
<span id="ast-basic-types-2"><a href="#ast-basic-types-2"></a><span class="ot">  typename ::</span> proxy a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="ast-basic-types-3"><a href="#ast-basic-types-3"></a></span>
<span id="ast-basic-types-4"><a href="#ast-basic-types-4"></a><span class="kw">data</span> <span class="dt">Pointer</span> a <span class="ot">=</span> <span class="dt">Pointer</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="ast-basic-types-5"><a href="#ast-basic-types-5"></a><span class="kw">data</span> <span class="dt">Function</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="ast-basic-types-6"><a href="#ast-basic-types-6"></a>  <span class="dt">Function</span><span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Function</span> a b</span>
<span id="ast-basic-types-7"><a href="#ast-basic-types-7"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="ast-basic-types-8"><a href="#ast-basic-types-8"></a><span class="kw">newtype</span> <span class="dt">Variable</span> a <span class="ot">=</span> <span class="dt">Variable</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="ast-basic-types-9"><a href="#ast-basic-types-9"></a></span>
<span id="ast-basic-types-10"><a href="#ast-basic-types-10"></a><span class="kw">instance</span> <span class="dt">Declarable</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="ast-basic-types-11"><a href="#ast-basic-types-11"></a>  typename _ <span class="ot">=</span> <span class="st">&quot;int&quot;</span></span>
<span id="ast-basic-types-12"><a href="#ast-basic-types-12"></a><span class="kw">instance</span> <span class="dt">Declarable</span> <span class="dt">Double</span> <span class="kw">where</span></span>
<span id="ast-basic-types-13"><a href="#ast-basic-types-13"></a>  typename _ <span class="ot">=</span> <span class="st">&quot;R&quot;</span></span>
<span id="ast-basic-types-14"><a href="#ast-basic-types-14"></a><span class="kw">instance</span> <span class="dt">Declarable</span> a <span class="ot">=&gt;</span> <span class="dt">Declarable</span> (<span class="dt">Pointer</span> a) <span class="kw">where</span></span>
<span id="ast-basic-types-15"><a href="#ast-basic-types-15"></a>  typename _ <span class="ot">=</span> typename (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="op">&lt;&gt;</span> <span class="st">&quot;*&quot;</span></span></code></pre></div>
<h3 id="expressions">Expressions</h3>
<p>An expression is any unit of code that can be said to have some value. Expressions can be arguments to functions, or they can assigned to a variable.</p>
<p><em>«ast-expression»=</em></p>
<div class="sourceCode" id="ast-expression"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-expression-1"><a href="#ast-expression-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></span>
<span id="ast-expression-2"><a href="#ast-expression-2"></a>    <span class="dt">Literal</span><span class="ot">        ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="ast-expression-3"><a href="#ast-expression-3"></a>    <span class="dt">IntegerValue</span><span class="ot">   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="ast-expression-4"><a href="#ast-expression-4"></a>    <span class="dt">RealValue</span><span class="ot">      ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Double</span></span>
<span id="ast-expression-5"><a href="#ast-expression-5"></a>    <span class="dt">ArrayRef</span><span class="ot">       ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Array</span> a)</span>
<span id="ast-expression-6"><a href="#ast-expression-6"></a>    <span class="dt">VarReference</span><span class="ot">   ::</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="ast-expression-7"><a href="#ast-expression-7"></a>    <span class="dt">ArrayIndex</span><span class="ot">     ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> [<span class="dt">Expr</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="ast-expression-8"><a href="#ast-expression-8"></a>    <span class="dt">TUnit</span><span class="ot">          ::</span> <span class="dt">Expr</span> ()</span>
<span id="ast-expression-9"><a href="#ast-expression-9"></a>    <span class="dt">Apply</span><span class="ot">          ::</span> <span class="dt">Syntax</span> (<span class="dt">ArgList</span> a) <span class="ot">=&gt;</span> <span class="dt">Function</span> a b <span class="ot">-&gt;</span> <span class="dt">ArgList</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b</span>
<span id="ast-expression-10"><a href="#ast-expression-10"></a></span>
<span id="ast-expression-11"><a href="#ast-expression-11"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">:+:</span></span></code></pre></div>
<p>The most important entries here are <code>(:+:)</code> and <code>Apply</code>. The <code>:+:</code> operator is used to construct an argument list. This argument list can then be applied to a function using <code>Apply</code>. As an example, here is the definition of <code>planNoTwiddle</code>. This function builds the AST for calling a no-twiddle FFT codelet, given an input and output array.</p>
<p><em>«synth-planNoTwiddle»=</em></p>
<div class="sourceCode" id="synth-planNoTwiddle"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="synth-planNoTwiddle-1"><a href="#synth-planNoTwiddle-1"></a>planNoTwiddle</span>
<span id="synth-planNoTwiddle-2"><a href="#synth-planNoTwiddle-2"></a><span class="ot">    ::</span> (<span class="dt">MonadError</span> <span class="dt">Text</span> m, <span class="dt">RealFloat</span> a)</span>
<span id="synth-planNoTwiddle-3"><a href="#synth-planNoTwiddle-3"></a>    <span class="ot">=&gt;</span> <span class="dt">NoTwiddleCodelet</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Expr</span> ())</span>
<span id="synth-planNoTwiddle-4"><a href="#synth-planNoTwiddle-4"></a>planNoTwiddle f inp out <span class="ot">=</span> <span class="kw">do</span></span>
<span id="synth-planNoTwiddle-5"><a href="#synth-planNoTwiddle-5"></a>  is  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">0</span></span>
<span id="synth-planNoTwiddle-6"><a href="#synth-planNoTwiddle-6"></a>  os  <span class="ot">&lt;-</span> stride out <span class="op">!?</span> <span class="dv">0</span></span>
<span id="synth-planNoTwiddle-7"><a href="#synth-planNoTwiddle-7"></a>  v   <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></span>
<span id="synth-planNoTwiddle-8"><a href="#synth-planNoTwiddle-8"></a>  ivs <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">1</span></span>
<span id="synth-planNoTwiddle-9"><a href="#synth-planNoTwiddle-9"></a>  ovs <span class="ot">&lt;-</span> stride out <span class="op">!?</span> <span class="dv">1</span></span>
<span id="synth-planNoTwiddle-10"><a href="#synth-planNoTwiddle-10"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Apply</span> f (<span class="dt">ArrayRef</span> (realPart inp) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart inp) <span class="op">:+:</span></span>
<span id="synth-planNoTwiddle-11"><a href="#synth-planNoTwiddle-11"></a>                    <span class="dt">ArrayRef</span> (realPart out) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart out) <span class="op">:+:</span></span>
<span id="synth-planNoTwiddle-12"><a href="#synth-planNoTwiddle-12"></a>                    <span class="dt">Literal</span> is <span class="op">:+:</span> <span class="dt">Literal</span> os <span class="op">:+:</span> <span class="dt">Literal</span> v <span class="op">:+:</span> <span class="dt">Literal</span> ivs <span class="op">:+:</span></span>
<span id="synth-planNoTwiddle-13"><a href="#synth-planNoTwiddle-13"></a>                    <span class="dt">Literal</span> ovs <span class="op">:+:</span> <span class="dt">Empty</span>)</span></code></pre></div>
<p>Note that the argument list is finalized with a <code>TNull</code>, otherwise the argument list would be improper.</p>
<p><em>«ast-statements»=</em></p>
<div class="sourceCode" id="ast-statements"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-statements-1"><a href="#ast-statements-1"></a><span class="kw">data</span> <span class="dt">Range</span> <span class="ot">=</span> <span class="dt">Range</span></span>
<span id="ast-statements-2"><a href="#ast-statements-2"></a>    {<span class="ot"> start ::</span> <span class="dt">Int</span></span>
<span id="ast-statements-3"><a href="#ast-statements-3"></a>    ,<span class="ot"> end   ::</span> <span class="dt">Int</span></span>
<span id="ast-statements-4"><a href="#ast-statements-4"></a>    ,<span class="ot"> step  ::</span> <span class="dt">Int</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="ast-statements-5"><a href="#ast-statements-5"></a></span>
<span id="ast-statements-6"><a href="#ast-statements-6"></a></span>
<span id="ast-statements-7"><a href="#ast-statements-7"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="kw">where</span></span>
<span id="ast-statements-8"><a href="#ast-statements-8"></a>    <span class="dt">VarDeclaration</span><span class="ot">   ::</span> (<span class="dt">Declarable</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Stmt</span></span>
<span id="ast-statements-9"><a href="#ast-statements-9"></a>    <span class="dt">Expression</span><span class="ot">       ::</span> <span class="dt">Expr</span> () <span class="ot">-&gt;</span> <span class="dt">Stmt</span></span>
<span id="ast-statements-10"><a href="#ast-statements-10"></a>    <span class="dt">ParallelFor</span><span class="ot">      ::</span> <span class="dt">Variable</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> [<span class="dt">Stmt</span>] <span class="ot">-&gt;</span> <span class="dt">Stmt</span></span>
<span id="ast-statements-11"><a href="#ast-statements-11"></a>    <span class="dt">Assignment</span><span class="ot">       ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Variable</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Stmt</span></span>
<span id="ast-statements-12"><a href="#ast-statements-12"></a>    <span class="co">-- FunctionDef      :: Function a b -&gt; [Stmt] -&gt; [Stmt] -&gt; Stmt</span></span></code></pre></div>
<h3 id="generating-code">Generating code</h3>
<p>Now we can generate C/OpenCL from our AST.</p>
<p><em>«ast-syntax»=</em></p>
<div class="sourceCode" id="ast-syntax"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="ast-syntax-1"><a href="#ast-syntax-1"></a><span class="kw">class</span> <span class="dt">Syntax</span> a <span class="kw">where</span></span>
<span id="ast-syntax-2"><a href="#ast-syntax-2"></a><span class="ot">  generate ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="ast-syntax-3"><a href="#ast-syntax-3"></a></span>
<span id="ast-syntax-4"><a href="#ast-syntax-4"></a><span class="kw">instance</span> <span class="dt">Syntax</span> (<span class="dt">ArgList</span> &#39;[]) <span class="kw">where</span></span>
<span id="ast-syntax-5"><a href="#ast-syntax-5"></a>    generate _ <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="ast-syntax-6"><a href="#ast-syntax-6"></a></span>
<span id="ast-syntax-7"><a href="#ast-syntax-7"></a><span class="kw">instance</span> (<span class="dt">Syntax</span> (<span class="dt">Expr</span> a), <span class="dt">Syntax</span> (<span class="dt">ArgList</span> l)) <span class="ot">=&gt;</span> <span class="dt">Syntax</span> (<span class="dt">ArgList</span> (a &#39;<span class="op">:</span> l)) <span class="kw">where</span></span>
<span id="ast-syntax-8"><a href="#ast-syntax-8"></a>    generate (a <span class="op">:+:</span> <span class="dt">Empty</span>) <span class="ot">=</span> generate a</span>
<span id="ast-syntax-9"><a href="#ast-syntax-9"></a>    generate (a <span class="op">:+:</span> b) <span class="ot">=</span> generate a <span class="op">&lt;&gt;</span> <span class="st">&quot;, &quot;</span> <span class="op">&lt;&gt;</span> generate b</span>
<span id="ast-syntax-10"><a href="#ast-syntax-10"></a></span>
<span id="ast-syntax-11"><a href="#ast-syntax-11"></a><span class="kw">instance</span> <span class="dt">Syntax</span> (<span class="dt">Expr</span> a) <span class="kw">where</span></span>
<span id="ast-syntax-12"><a href="#ast-syntax-12"></a>  generate (<span class="dt">Literal</span> x) <span class="ot">=</span> tshow x</span>
<span id="ast-syntax-13"><a href="#ast-syntax-13"></a>  generate (<span class="dt">IntegerValue</span> x) <span class="ot">=</span> tshow x</span>
<span id="ast-syntax-14"><a href="#ast-syntax-14"></a>  generate (<span class="dt">RealValue</span> x) <span class="ot">=</span> tshow x</span>
<span id="ast-syntax-15"><a href="#ast-syntax-15"></a>  generate (<span class="dt">ArrayRef</span> x)</span>
<span id="ast-syntax-16"><a href="#ast-syntax-16"></a>    <span class="op">|</span> (offset x) <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> name x</span>
<span id="ast-syntax-17"><a href="#ast-syntax-17"></a>    <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">=</span> name x <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> tshow (offset x)</span>
<span id="ast-syntax-18"><a href="#ast-syntax-18"></a>  generate (<span class="dt">VarReference</span> (<span class="dt">Variable</span> x)) <span class="ot">=</span> x</span>
<span id="ast-syntax-19"><a href="#ast-syntax-19"></a>  generate (<span class="dt">ArrayIndex</span> a i) <span class="ot">=</span> name a <span class="op">&lt;&gt;</span> <span class="st">&quot;[&lt;index expression&gt;]&quot;</span></span>
<span id="ast-syntax-20"><a href="#ast-syntax-20"></a>  generate (<span class="dt">Apply</span> (<span class="dt">Function</span> f) a) <span class="ot">=</span> f <span class="op">&lt;&gt;</span> <span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> generate a <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span></span>
<span id="ast-syntax-21"><a href="#ast-syntax-21"></a>  generate <span class="dt">TUnit</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="ast-syntax-22"><a href="#ast-syntax-22"></a></span>
<span id="ast-syntax-23"><a href="#ast-syntax-23"></a><span class="kw">instance</span> <span class="dt">Syntax</span> <span class="dt">Stmt</span> <span class="kw">where</span></span>
<span id="ast-syntax-24"><a href="#ast-syntax-24"></a>  generate (<span class="dt">VarDeclaration</span> v<span class="op">@</span>(<span class="dt">Variable</span> x)) <span class="ot">=</span> typename v <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></span>
<span id="ast-syntax-25"><a href="#ast-syntax-25"></a>  generate (<span class="dt">Expression</span> e) <span class="ot">=</span> generate e <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></span>
<span id="ast-syntax-26"><a href="#ast-syntax-26"></a>  generate (<span class="dt">ParallelFor</span> (<span class="dt">Variable</span> v) (<span class="dt">Range</span> a b s) body) <span class="ot">=</span></span>
<span id="ast-syntax-27"><a href="#ast-syntax-27"></a>    <span class="st">&quot;for (int &quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;=&quot;</span> <span class="op">&lt;&gt;</span> tshow a <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;&quot;</span></span>
<span id="ast-syntax-28"><a href="#ast-syntax-28"></a>    <span class="op">&lt;&gt;</span> tshow b <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span> <span class="op">&lt;&gt;</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot;+=&quot;</span> <span class="op">&lt;&gt;</span> tshow s <span class="op">&lt;&gt;</span> <span class="st">&quot;) {\n&quot;</span></span>
<span id="ast-syntax-29"><a href="#ast-syntax-29"></a>    <span class="op">&lt;&gt;</span> T.unlines (<span class="fu">map</span> generate body) <span class="op">&lt;&gt;</span> <span class="st">&quot;\n}&quot;</span></span>
<span id="ast-syntax-30"><a href="#ast-syntax-30"></a>  generate (<span class="dt">Assignment</span> (<span class="dt">Variable</span> v) e) <span class="ot">=</span> v <span class="op">&lt;&gt;</span> <span class="st">&quot; = &quot;</span> <span class="op">&lt;&gt;</span> generate e <span class="op">&lt;&gt;</span> <span class="st">&quot;;&quot;</span></span></code></pre></div>
<h3 id="ast-module">AST Module</h3>
<p><em>file: «src/AST.hs»=</em></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>haskell<span class="op">-</span>extensions<span class="op">&gt;&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">module</span> <span class="dt">AST</span> <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">import</span> <span class="dt">Array</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>ocl<span class="op">-</span>namespaces<span class="op">&gt;&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>basic<span class="op">-</span>types<span class="op">&gt;&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>typelists<span class="op">&gt;&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>expression<span class="op">&gt;&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>statements<span class="op">&gt;&gt;</span></span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="kw">data</span> <span class="dt">FunctionDecl</span> a b <span class="ot">=</span> <span class="dt">FunctionDecl</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>  {<span class="ot"> functionName ::</span> <span class="dt">Text</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>  ,<span class="ot"> argNames     ::</span> [<span class="dt">Text</span>]</span>
<span id="cb6-21"><a href="#cb6-21"></a>  ,<span class="ot"> functionBody ::</span> [<span class="dt">Stmt</span>] }</span>
<span id="cb6-22"><a href="#cb6-22"></a></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="op">&lt;&lt;</span>ast<span class="op">-</span>syntax<span class="op">&gt;&gt;</span></span></code></pre></div>
<h2 id="synthesis-of-fft">Synthesis of FFT</h2>
<p>When discussing expressions in the abstract syntax tree, the definition of <code>planNoTwiddle</code> was shown. Similarly the twiddle codelet:</p>
<p><em>«synth-planTwiddle»=</em></p>
<div class="sourceCode" id="synth-planTwiddle"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="synth-planTwiddle-1"><a href="#synth-planTwiddle-1"></a>planTwiddle</span>
<span id="synth-planTwiddle-2"><a href="#synth-planTwiddle-2"></a><span class="ot">    ::</span> (<span class="dt">MonadError</span> <span class="dt">Text</span> m, <span class="dt">RealFloat</span> a)</span>
<span id="synth-planTwiddle-3"><a href="#synth-planTwiddle-3"></a>    <span class="ot">=&gt;</span> <span class="dt">TwiddleCodelet</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Expr</span> ())</span>
<span id="synth-planTwiddle-4"><a href="#synth-planTwiddle-4"></a>planTwiddle f inp twiddle <span class="ot">=</span> <span class="kw">do</span></span>
<span id="synth-planTwiddle-5"><a href="#synth-planTwiddle-5"></a>  rs  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">0</span></span>
<span id="synth-planTwiddle-6"><a href="#synth-planTwiddle-6"></a>  me  <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></span>
<span id="synth-planTwiddle-7"><a href="#synth-planTwiddle-7"></a>  ms  <span class="ot">&lt;-</span> stride inp <span class="op">!?</span> <span class="dv">1</span></span>
<span id="synth-planTwiddle-8"><a href="#synth-planTwiddle-8"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Apply</span> f (<span class="dt">ArrayRef</span> (realPart inp) <span class="op">:+:</span> <span class="dt">ArrayRef</span> (imagPart inp) <span class="op">:+:</span></span>
<span id="synth-planTwiddle-9"><a href="#synth-planTwiddle-9"></a>                    <span class="dt">ArrayRef</span> (realPart twiddle) <span class="op">:+:</span> <span class="dt">Literal</span> rs <span class="op">:+:</span> <span class="dt">Literal</span> <span class="dv">0</span> <span class="op">:+:</span></span>
<span id="synth-planTwiddle-10"><a href="#synth-planTwiddle-10"></a>                    <span class="dt">Literal</span> me <span class="op">:+:</span> <span class="dt">Literal</span> ms <span class="op">:+:</span> <span class="dt">Empty</span>)</span></code></pre></div>
<h3 id="algorithm">Algorithm</h3>
<p>An FFT algorithm now is a collection of codelets, twiddle factors and a list of statements defining how to synthesise the larger FFT.</p>
<p><em>«synth-algorithm»=</em></p>
<div class="sourceCode" id="synth-algorithm"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="synth-algorithm-1"><a href="#synth-algorithm-1"></a><span class="kw">data</span> <span class="dt">Algorithm</span> <span class="ot">=</span> <span class="dt">Algorithm</span></span>
<span id="synth-algorithm-2"><a href="#synth-algorithm-2"></a>  {<span class="ot"> codelets   ::</span> <span class="dt">Set</span> <span class="dt">Codelet</span></span>
<span id="synth-algorithm-3"><a href="#synth-algorithm-3"></a>  ,<span class="ot"> twiddles   ::</span> <span class="dt">Set</span> <span class="dt">Shape</span></span>
<span id="synth-algorithm-4"><a href="#synth-algorithm-4"></a>  ,<span class="ot"> statements ::</span> [<span class="dt">Stmt</span>] }</span></code></pre></div>
<p>To build up an algorithm from pieces, we derive an instance of <code>Monoid</code> for both <code>Algorithm</code> and <code>Either Text Algorithm</code>, the latter handling errors during code generation. We can use the <code>&lt;&gt;</code> operator to take the union of the sets of codelets and twiddles, as well as appending to the list of statements.</p>
<p><em>«synth-algorithm»=+</em></p>
<div class="sourceCode" id="synth-algorithm"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="synth-algorithm-1"><a href="#synth-algorithm-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Algorithm</span> <span class="kw">where</span></span>
<span id="synth-algorithm-2"><a href="#synth-algorithm-2"></a>  (<span class="dt">Algorithm</span> c1 t1 s1) <span class="op">&lt;&gt;</span> (<span class="dt">Algorithm</span> c2 t2 s2) <span class="ot">=</span> <span class="dt">Algorithm</span> (c1 <span class="op">&lt;&gt;</span> c2) (t1 <span class="op">&lt;&gt;</span> t2) (s1 <span class="op">&lt;&gt;</span> s2)</span>
<span id="synth-algorithm-3"><a href="#synth-algorithm-3"></a></span>
<span id="synth-algorithm-4"><a href="#synth-algorithm-4"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Algorithm</span> <span class="kw">where</span></span>
<span id="synth-algorithm-5"><a href="#synth-algorithm-5"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Algorithm</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="synth-algorithm-6"><a href="#synth-algorithm-6"></a></span>
<span id="synth-algorithm-7"><a href="#synth-algorithm-7"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">Semigroup</span> (<span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span>) <span class="kw">where</span></span>
<span id="synth-algorithm-8"><a href="#synth-algorithm-8"></a>  (<span class="dt">Left</span> a) <span class="op">&lt;&gt;</span> _ <span class="ot">=</span> <span class="dt">Left</span> a</span>
<span id="synth-algorithm-9"><a href="#synth-algorithm-9"></a>  _ <span class="op">&lt;&gt;</span> (<span class="dt">Left</span> b) <span class="ot">=</span> <span class="dt">Left</span> b</span>
<span id="synth-algorithm-10"><a href="#synth-algorithm-10"></a>  (<span class="dt">Right</span> a) <span class="op">&lt;&gt;</span> (<span class="dt">Right</span> b) <span class="ot">=</span> <span class="dt">Right</span> (a <span class="op">&lt;&gt;</span> b)</span>
<span id="synth-algorithm-11"><a href="#synth-algorithm-11"></a></span>
<span id="synth-algorithm-12"><a href="#synth-algorithm-12"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span>) <span class="kw">where</span></span>
<span id="synth-algorithm-13"><a href="#synth-algorithm-13"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="fu">return</span> <span class="fu">mempty</span></span></code></pre></div>
<h3 id="synthesis-module">Synthesis Module</h3>
<p><em>file: «src/Synthesis.hs»=</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE DataKinds,GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">module</span> <span class="dt">Synthesis</span> <span class="kw">where</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">import</span> <span class="dt">Data.Complex</span> (<span class="dt">Complex</span>(..))</span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="co">-- import qualified Data.Text as T</span></span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sort)</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">import</span> <span class="dt">AST</span></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="kw">import</span> <span class="dt">Array</span></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="kw">import</span> <span class="dt">Codelet</span></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="kw">import</span> <span class="dt">TwiddleFactors</span></span>
<span id="cb7-22"><a href="#cb7-22"></a></span>
<span id="cb7-23"><a href="#cb7-23"></a><span class="kw">import</span> <span class="dt">Math.NumberTheory.Primes.Factorisation</span> (factorise)</span>
<span id="cb7-24"><a href="#cb7-24"></a></span>
<span id="cb7-25"><a href="#cb7-25"></a><span class="ot">(!?) ::</span> <span class="dt">MonadError</span> <span class="dt">Text</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m a</span>
<span id="cb7-26"><a href="#cb7-26"></a>[] <span class="op">!?</span> i <span class="ot">=</span> throwError <span class="op">$</span> <span class="st">&quot;List index error: list &quot;</span> <span class="op">&lt;&gt;</span> tshow (i <span class="op">+</span> <span class="dv">1</span>) <span class="op">&lt;&gt;</span> <span class="st">&quot; too short.&quot;</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>(x<span class="op">:</span>xs) <span class="op">!?</span> i</span>
<span id="cb7-28"><a href="#cb7-28"></a>  <span class="op">|</span> i <span class="op">==</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="fu">return</span> x</span>
<span id="cb7-29"><a href="#cb7-29"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> xs <span class="op">!?</span> (i <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a><span class="op">&lt;&lt;</span>synth<span class="op">-</span>planNoTwiddle<span class="op">&gt;&gt;</span></span>
<span id="cb7-32"><a href="#cb7-32"></a><span class="op">&lt;&lt;</span>synth<span class="op">-</span>planTwiddle<span class="op">&gt;&gt;</span></span>
<span id="cb7-33"><a href="#cb7-33"></a><span class="op">&lt;&lt;</span>synth<span class="op">-</span>algorithm<span class="op">&gt;&gt;</span></span>
<span id="cb7-34"><a href="#cb7-34"></a></span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="ot">defineTwiddles ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Algorithm</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>defineTwiddles shape <span class="ot">=</span> <span class="dt">Algorithm</span> <span class="fu">mempty</span> (S.fromList [shape]) <span class="fu">mempty</span></span>
<span id="cb7-37"><a href="#cb7-37"></a></span>
<span id="cb7-38"><a href="#cb7-38"></a>noTwiddleFFT</span>
<span id="cb7-39"><a href="#cb7-39"></a><span class="ot">    ::</span> <span class="dt">RealFloat</span> a</span>
<span id="cb7-40"><a href="#cb7-40"></a>    <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>noTwiddleFFT n inp out <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-42"><a href="#cb7-42"></a>  <span class="kw">let</span> codelet <span class="ot">=</span> <span class="dt">Codelet</span> <span class="dt">NoTwiddle</span> n</span>
<span id="cb7-43"><a href="#cb7-43"></a>      f <span class="ot">=</span> <span class="dt">Function</span> (codeletName codelet)<span class="ot"> ::</span> <span class="dt">NoTwiddleCodelet</span> a</span>
<span id="cb7-44"><a href="#cb7-44"></a>  plan <span class="ot">&lt;-</span> planNoTwiddle f inp out</span>
<span id="cb7-45"><a href="#cb7-45"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Algorithm</span> (S.fromList [codelet]) <span class="fu">mempty</span> [<span class="dt">Expression</span> plan]</span>
<span id="cb7-46"><a href="#cb7-46"></a></span>
<span id="cb7-47"><a href="#cb7-47"></a>twiddleFFT</span>
<span id="cb7-48"><a href="#cb7-48"></a><span class="ot">    ::</span> <span class="dt">RealFloat</span> a</span>
<span id="cb7-49"><a href="#cb7-49"></a>    <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></span>
<span id="cb7-50"><a href="#cb7-50"></a>twiddleFFT n inp twiddle <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-51"><a href="#cb7-51"></a>  <span class="kw">let</span> codelet <span class="ot">=</span> <span class="dt">Codelet</span> <span class="dt">Twiddle</span> n</span>
<span id="cb7-52"><a href="#cb7-52"></a>      f <span class="ot">=</span> <span class="dt">Function</span> (codeletName codelet)<span class="ot"> ::</span> <span class="dt">TwiddleCodelet</span> a</span>
<span id="cb7-53"><a href="#cb7-53"></a>  plan <span class="ot">&lt;-</span> planTwiddle f inp twiddle</span>
<span id="cb7-54"><a href="#cb7-54"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Algorithm</span> (S.fromList [codelet]) <span class="fu">mempty</span> [<span class="dt">Expression</span> plan]</span>
<span id="cb7-55"><a href="#cb7-55"></a></span>
<span id="cb7-56"><a href="#cb7-56"></a>nFactorFFT</span>
<span id="cb7-57"><a href="#cb7-57"></a><span class="ot">    ::</span> <span class="dt">RealFloat</span> a</span>
<span id="cb7-58"><a href="#cb7-58"></a>    <span class="ot">=&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></span>
<span id="cb7-59"><a href="#cb7-59"></a>nFactorFFT [] _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="fu">mempty</span></span>
<span id="cb7-60"><a href="#cb7-60"></a>nFactorFFT [x] inp out <span class="ot">=</span> noTwiddleFFT x inp out</span>
<span id="cb7-61"><a href="#cb7-61"></a>nFactorFFT (x<span class="op">:</span>xs) inp out <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-62"><a href="#cb7-62"></a>    <span class="kw">let</span> n <span class="ot">=</span> <span class="fu">product</span> xs</span>
<span id="cb7-63"><a href="#cb7-63"></a>        w_array <span class="ot">=</span> <span class="dt">Array</span> (factorsName [n, x]) [n, x] (fromShape [n, x] <span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb7-64"><a href="#cb7-64"></a>        subfft i <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-65"><a href="#cb7-65"></a>            inp&#39; <span class="ot">&lt;-</span> reshape [x, n] <span class="op">=&lt;&lt;</span> select <span class="dv">1</span> i inp</span>
<span id="cb7-66"><a href="#cb7-66"></a>            out&#39; <span class="ot">&lt;-</span> reshape [n, x] <span class="op">=&lt;&lt;</span> select <span class="dv">1</span> i out</span>
<span id="cb7-67"><a href="#cb7-67"></a>            nFactorFFT xs (transpose inp&#39;) out&#39;</span>
<span id="cb7-68"><a href="#cb7-68"></a>                <span class="op">&lt;&gt;</span> twiddleFFT x (transpose out&#39;) w_array</span>
<span id="cb7-69"><a href="#cb7-69"></a>                <span class="op">&lt;&gt;</span> <span class="dt">Right</span> (defineTwiddles [n, x])</span>
<span id="cb7-70"><a href="#cb7-70"></a></span>
<span id="cb7-71"><a href="#cb7-71"></a>    l <span class="ot">&lt;-</span> shape inp <span class="op">!?</span> <span class="dv">1</span></span>
<span id="cb7-72"><a href="#cb7-72"></a>    <span class="fu">mconcat</span> (<span class="fu">map</span> subfft [<span class="dv">0</span><span class="op">..</span>(l<span class="op">-</span><span class="dv">1</span>)])</span>
<span id="cb7-73"><a href="#cb7-73"></a></span>
<span id="cb7-74"><a href="#cb7-74"></a><span class="ot">factors ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb7-75"><a href="#cb7-75"></a>factors n <span class="ot">=</span> <span class="fu">sort</span> <span class="op">$</span> <span class="fu">concatMap</span> (\(i, m) <span class="ot">-&gt;</span> <span class="fu">take</span> m <span class="op">$</span> <span class="fu">repeat</span> (<span class="fu">fromIntegral</span><span class="ot"> i ::</span> <span class="dt">Int</span>)) (factorise <span class="op">$</span> <span class="fu">fromIntegral</span> n)</span>
<span id="cb7-76"><a href="#cb7-76"></a></span>
<span id="cb7-77"><a href="#cb7-77"></a><span class="ot">fullFactorFFT ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> (<span class="dt">Complex</span> a) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Algorithm</span></span>
<span id="cb7-78"><a href="#cb7-78"></a>fullFactorFFT n <span class="ot">=</span> nFactorFFT (factors n)</span></code></pre></div>
<h2 id="appendix-miscellaneous-functions">Appendix: Miscellaneous functions</h2>
<p><em>file: «src/Lib.hs»=</em></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="op">&lt;&lt;</span>lib<span class="op">-</span>list<span class="op">-</span>manipulation<span class="op">&gt;&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ot">tshow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>tshow <span class="ot">=</span> T.pack <span class="op">.</span> <span class="fu">show</span></span></code></pre></div>
<h3 id="list-manipulation">List manipulation</h3>
<p>We will be manipulating the shape and stride lists to slice the n-dimensional array. These operations just didn’t make it into Haskell’s standard library.</p>
<p><em>«lib-list-manipulation»=</em></p>
<div class="sourceCode" id="lib-list-manipulation"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="lib-list-manipulation-1"><a href="#lib-list-manipulation-1"></a><span class="ot">remove ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a]</span>
<span id="lib-list-manipulation-2"><a href="#lib-list-manipulation-2"></a>remove [] _ <span class="ot">=</span> []</span>
<span id="lib-list-manipulation-3"><a href="#lib-list-manipulation-3"></a>remove (x<span class="op">:</span>xs) n</span>
<span id="lib-list-manipulation-4"><a href="#lib-list-manipulation-4"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> xs</span>
<span id="lib-list-manipulation-5"><a href="#lib-list-manipulation-5"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> remove xs (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="lib-list-manipulation-6"><a href="#lib-list-manipulation-6"></a></span>
<span id="lib-list-manipulation-7"><a href="#lib-list-manipulation-7"></a><span class="ot">replace ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="lib-list-manipulation-8"><a href="#lib-list-manipulation-8"></a>replace [] _  _ <span class="ot">=</span> []</span>
<span id="lib-list-manipulation-9"><a href="#lib-list-manipulation-9"></a>replace (x<span class="op">:</span>xs) n y</span>
<span id="lib-list-manipulation-10"><a href="#lib-list-manipulation-10"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> y<span class="op">:</span>xs</span>
<span id="lib-list-manipulation-11"><a href="#lib-list-manipulation-11"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> replace xs (n <span class="op">-</span> <span class="dv">1</span>) y</span>
<span id="lib-list-manipulation-12"><a href="#lib-list-manipulation-12"></a></span>
<span id="lib-list-manipulation-13"><a href="#lib-list-manipulation-13"></a><span class="ot">insert ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="lib-list-manipulation-14"><a href="#lib-list-manipulation-14"></a>insert [] _  _ <span class="ot">=</span> []</span>
<span id="lib-list-manipulation-15"><a href="#lib-list-manipulation-15"></a>insert (x<span class="op">:</span>xs) n y</span>
<span id="lib-list-manipulation-16"><a href="#lib-list-manipulation-16"></a>    <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> y<span class="op">:</span>x<span class="op">:</span>xs</span>
<span id="lib-list-manipulation-17"><a href="#lib-list-manipulation-17"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">:</span> insert xs (n <span class="op">-</span> <span class="dv">1</span>) y</span></code></pre></div>
<h2 id="unit-tests-1">Unit tests</h2>
<p><em>file: «test/Spec.hs»=</em></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">import</span> <span class="dt">Test.Hspec</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">import</span> <span class="dt">Data.Complex</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (liftA2)</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> (<span class="dt">Vector</span>)</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">import</span> <span class="dt">Array</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">import</span> <span class="dt">Lib</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">import</span> <span class="dt">TwiddleFactors</span></span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="op">&lt;&lt;</span>test<span class="op">-</span>predicates<span class="op">&gt;&gt;</span></span>
<span id="cb9-15"><a href="#cb9-15"></a></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="ot">testTwiddleFactors ::</span> <span class="dt">Spec</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>testTwiddleFactors <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span class="op">&lt;&lt;</span>test<span class="op">-</span>twiddle<span class="op">-</span>factors<span class="op">&gt;&gt;</span></span>
<span id="cb9-19"><a href="#cb9-19"></a></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-21"><a href="#cb9-21"></a>main <span class="ot">=</span> hspec <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>    describe <span class="st">&quot;Strides.fromShape&quot;</span> <span class="op">$</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>        it <span class="st">&quot;computes strides from shapes&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>            fromShape [<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>] <span class="dv">1</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>]</span>
<span id="cb9-25"><a href="#cb9-25"></a>            fromShape [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>] <span class="dv">1</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>]</span>
<span id="cb9-26"><a href="#cb9-26"></a></span>
<span id="cb9-27"><a href="#cb9-27"></a>    describe <span class="st">&quot;Strides.remove&quot;</span> <span class="op">$</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>        it <span class="st">&quot;drops indexed entry from list&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>            remove [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="ot">`shouldBe`</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-30"><a href="#cb9-30"></a>            remove [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>]</span>
<span id="cb9-31"><a href="#cb9-31"></a></span>
<span id="cb9-32"><a href="#cb9-32"></a>    describe <span class="st">&quot;Strides.replace&quot;</span> <span class="op">$</span></span>
<span id="cb9-33"><a href="#cb9-33"></a>        it <span class="st">&quot;replaces entry at index&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>            replace [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-35"><a href="#cb9-35"></a>            replace [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">4</span>]</span>
<span id="cb9-36"><a href="#cb9-36"></a></span>
<span id="cb9-37"><a href="#cb9-37"></a>    describe <span class="st">&quot;Strides.insert&quot;</span> <span class="op">$</span></span>
<span id="cb9-38"><a href="#cb9-38"></a>        it <span class="st">&quot;inserts entry at index&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-39"><a href="#cb9-39"></a>            insert [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">0</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-40"><a href="#cb9-40"></a>            insert [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>] <span class="dv">2</span> <span class="dv">7</span> <span class="ot">`shouldBe`</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb9-41"><a href="#cb9-41"></a></span>
<span id="cb9-42"><a href="#cb9-42"></a>    <span class="kw">let</span> a1 <span class="ot">=</span> floatArray <span class="st">&quot;test&quot;</span> [<span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb9-43"><a href="#cb9-43"></a>    describe <span class="st">&quot;Strides.select&quot;</span> <span class="op">$</span></span>
<span id="cb9-44"><a href="#cb9-44"></a>        it <span class="st">&quot;selects sub-array&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-45"><a href="#cb9-45"></a>            <span class="kw">let</span> a103 <span class="ot">=</span> select a1 <span class="dv">0</span> <span class="dv">3</span></span>
<span id="cb9-46"><a href="#cb9-46"></a>            <span class="kw">let</span> a112 <span class="ot">=</span> select a1 <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb9-47"><a href="#cb9-47"></a>            (shape <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">5</span>]</span>
<span id="cb9-48"><a href="#cb9-48"></a>            (stride <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">4</span>]</span>
<span id="cb9-49"><a href="#cb9-49"></a>            (offset <span class="op">&lt;$&gt;</span> a103) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> <span class="dv">3</span></span>
<span id="cb9-50"><a href="#cb9-50"></a>            (shape <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">4</span>]</span>
<span id="cb9-51"><a href="#cb9-51"></a>            (stride <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> [<span class="dv">1</span>]</span>
<span id="cb9-52"><a href="#cb9-52"></a>            (offset <span class="op">&lt;$&gt;</span> a112) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> <span class="dv">8</span></span>
<span id="cb9-53"><a href="#cb9-53"></a></span>
<span id="cb9-54"><a href="#cb9-54"></a>    testTwiddleFactors</span></code></pre></div>
<h2 id="run-models">Run models</h2>
<p>For testing a function from the host, we can call a kernel directly if it is decorated with <code>__kernel</code> and the appropriate name spaces in the arguments. Usually this is not how the Fourier transforms will be called. If we just leave the codelets in their original C form, we can call them from inside other kernels. These calls are then inlined by the OpenCL compiler.</p>
<p>There are three modes to run our functions:</p>
<ul>
<li><code>__kernel</code> from host directly</li>
<li>write a small <code>main</code> kernel to test kernel on GPU</li>
<li>use channels to compute on input stream</li>
</ul>
<p>The third option is not entirely trivial.</p>
<h3 id="channels">Channels</h3>
<p>A generic channel component can be tested as follows. We first enable the <code>cl_intel_channels</code> extension.</p>
<p><em>«enable-channel-extension»=</em></p>
<div class="sourceCode" id="enable-channel-extension"><pre class="sourceCode opencl"><code class="sourceCode opencl"><span id="enable-channel-extension-1"><a href="#enable-channel-extension-1"></a><span class="ot">#pragma OPENCL EXTENSION cl_intel_channels : enable</span></span></code></pre></div>
<p>Define input and output channels,</p>
<p><em>«define-channels»=</em></p>
<div class="sourceCode" id="define-channels"><pre class="sourceCode opencl"><code class="sourceCode opencl"><span id="define-channels-1"><a href="#define-channels-1"></a>channel <span class="dt">float2</span> in_channel, out_channel;</span></code></pre></div>
<p>and have a <code>autorun</code> kernel that runs an infinite loop.</p>
<p><em>«autorun-kernel»=</em></p>
<div class="sourceCode" id="autorun-kernel"><pre class="sourceCode opencl"><code class="sourceCode opencl"><span id="autorun-kernel-1"><a href="#autorun-kernel-1"></a><span class="kw">__kernel</span></span>
<span id="autorun-kernel-2"><a href="#autorun-kernel-2"></a>__attribute__((autorun))</span>
<span id="autorun-kernel-3"><a href="#autorun-kernel-3"></a>__attribute__((max_global_work_dim(<span class="dv">0</span>)))</span>
<span id="autorun-kernel-4"><a href="#autorun-kernel-4"></a><span class="dt">void</span> do_fft()</span>
<span id="autorun-kernel-5"><a href="#autorun-kernel-5"></a>{</span>
<span id="autorun-kernel-6"><a href="#autorun-kernel-6"></a>  <span class="kw">while</span> (true) {</span>
<span id="autorun-kernel-7"><a href="#autorun-kernel-7"></a>    &lt;&lt;-compute-&gt;&gt;</span>
<span id="autorun-kernel-8"><a href="#autorun-kernel-8"></a>  }</span>
<span id="autorun-kernel-9"><a href="#autorun-kernel-9"></a>}</span></code></pre></div>
<p>Inside the computation we read from input and write to output,</p>
<p>``` {.opencl #-compute-} float2 a[CHUNK_SIZE];</p>
<p>for (unsigned i = 0; i &lt; CHUNK_SIZE; ++i) a[i] = read_channel_intel(in_channel);</p>
<p>// do Fourier transform</p>
<p>for (unsigned i = 0; i &lt; CHUNK_SIZE; ++i) write_channel_intel(out_channel, a[i]); }</p>
<pre><code>
where `CHUNK_SIZE` is some integer constant. We&#39;ll define two more kernels that fill the input channel from some source,

``` {.opencl #channel-source}
__attribute__((max_global_work_dim(0)))
__kernel void source(__global const volatile float2 *in, unsigned count)
{
  for (unsigned i = 0; i &lt; count; i ++)
    write_channel_intel(in_channel, in[i]);
}</code></pre>
<p>and read the output channel onto some sink.</p>
<p><em>«channel-sink»=</em></p>
<div class="sourceCode" id="channel-sink"><pre class="sourceCode opencl"><code class="sourceCode opencl"><span id="channel-sink-1"><a href="#channel-sink-1"></a>__attribute__((max_global_work_dim(<span class="dv">0</span>)))</span>
<span id="channel-sink-2"><a href="#channel-sink-2"></a><span class="kw">__kernel</span> <span class="dt">void</span> sink(<span class="kw">__global</span> <span class="dt">float2</span> *out, <span class="dt">unsigned</span> count)</span>
<span id="channel-sink-3"><a href="#channel-sink-3"></a>{</span>
<span id="channel-sink-4"><a href="#channel-sink-4"></a>  <span class="kw">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; count; i ++)</span>
<span id="channel-sink-5"><a href="#channel-sink-5"></a>    out[i] = read_channel_intel(out_channel);</span>
<span id="channel-sink-6"><a href="#channel-sink-6"></a>}</span></code></pre></div>
<p>This channel architecture enables a form of composability that matches the data-flow character of the FPGA.</p>
<h3 id="auto-kernel-generator">Auto-kernel generator</h3>
<p>Given an input and output channel name we can automatically generate a Fourier transform auto-kernel.</p>
</body>
</html>
